{"version":3,"file":"142.6f46ecf1ff524851e045.bundle.js","mappings":"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","sources":["webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack:///./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","webpack:///./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack:///./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n"],"names":["addBits","srcParts","parts","name","i","part","toLocaleLowerCase","sanitisedPart","replace","push","warn","findHooksRx","compileHooks","programSrc","match","map","hook","forEach","extractInputs","fragmentSource","out","regex","exec","compileInputs","fragments","template","sort","results","fragment","header","mainInput","finalString","inValue","join","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","length","cacheMap","Object","create","bitCacheMap","Map","CACHE_UID","compileHighShaderGl","bits","cacheId","generateCacheId","compileBits","vertex","highFragment","has","set","get","a","b","vertexParts","shaderBit","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","source","vertexFragments","filter","v","fragmentFragments","compiledVertex","index","mainStruct","indexOf","mainStart","value","mainEnd","extractVariableName","compiledCode","compileOutputs","compileInputsAndOutputs","compileHighShader","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram","colorBit","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","bindingIndex","generateSampleSrc","generateTextureBatchBit","end","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","roundPixelsBit","roundPixelsBitGl","color32BitToUniform","abgr","offset","alpha","BatchableSprite","constructor","this","vertexSize","indexSize","location","batcher","batch","roundPixels","blendMode","renderable","groupBlendMode","packAttributes","float32View","uint32View","textureId","sprite","texture","wt","groupTransform","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset"],"sourceRoot":""}