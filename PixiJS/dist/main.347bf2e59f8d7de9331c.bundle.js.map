{"version":3,"file":"main.347bf2e59f8d7de9331c.bundle.js","mappings":"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","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///webpack/runtime/load script","webpack:///./src/scripts/client/gixi/systems/base/SystemBase.ts","webpack:///./src/scripts/client/gixi/GixiUtility.ts","webpack:///./src/scripts/client/gixi/systems/CollisionSystem.ts","webpack:///./src/scripts/client/gixi/ActorContainer.ts","webpack:///./src/scripts/client/gixi/systems/InputSystem.ts","webpack:///./src/scripts/client/gixi/systems/AudioSystem.ts","webpack:///./src/scripts/client/gixi/systems/MultiplayerSystem.ts","webpack:///./src/scripts/client/gixi/systems/TilemapCollisionSystem.ts","webpack:///./src/scripts/client/gixi/GixiApplication.ts","webpack:///./src/scripts/client/gixi/tilemap/TilemapCollisionSystem.ts","webpack:///./src/scripts/client/gixi/tilemap/Tilemap.ts","webpack:///./src/scripts/client/gixi/GixiText.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/ui/InstructionsText.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/ui/ScoreText.ts","webpack:///./src/scripts/client/gixi/ActorAnimated.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/TreasureHunter2DConstants.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/tileMap/tileMapObjects/CoinTilemapObject.ts","webpack:///./src/scripts/client/gixi/ActorStatic.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/tileMap/tileMapObjects/ChestTilemapObject.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/Player.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/tileMap/tileMapObjects/base/BaseSpawnpointTilemapObject.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/tileMap/tileMapObjects/PlayerSpawnpointTilemapObject.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/tileMap/tileMapObjects/EnemySpawnpointTilemapObject.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/tileMap/TilemapItemFactoryCustom.ts","webpack:///./src/scripts/client/core/observables/Observable.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/DebugMarker.ts","webpack:///./src/scripts/client/projects/treasureHunter2D/Enemy.ts","webpack:///./src/scripts/client/index.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/ensure chunk","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/get mini-css chunk filename","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var inProgress = {};\n// data-webpack is not used as build has no uniqueName\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","import { GixiApplication } from \"../../GixiApplication\";\r\nimport { IInitializableAsync } from \"../../interfaces/IInitializeAsync\";\r\n\r\n\r\n/**\r\n * \r\n */\r\nexport interface ISystemBase extends IInitializableAsync {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Methods --------------------------------------\r\n}\r\n\r\n/**\r\n * \r\n */\r\nexport class SystemBase implements ISystemBase {\r\n\r\n    // Properties -----------------------------------\r\n    get isInitialized(): boolean {\r\n        return this._isInitialized;\r\n    }\r\n\r\n    // Fields ---------------------------------------\r\n    protected _app: GixiApplication;\r\n    protected _isInitialized: boolean = false;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n        this._app = app;\r\n    }\r\n\r\n    public async initializeAsync(): Promise<any> {\r\n        //console.log(\"Method must be overriden\");\r\n    }\r\n\r\n    public requireIsInitialized() {\r\n        if (!this.isInitialized) {\r\n            throw new Error('Systems are not initialized.');\r\n        }\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n}","import * as PIXI from 'pixi.js';\r\nimport { ICollisionSystemBody } from './interfaces/ICollisionSystemBody';\r\n\r\n/**\r\n * Common functionality\r\n */\r\nexport class GixiUtility {\r\n\r\n  // Properties -----------------------------------\r\n\r\n  // Fields ---------------------------------------\r\n\r\n  // Methods --------------------------------------\r\n  public static textureIsNullOrEmpty(texture: PIXI.Texture): boolean {\r\n    return texture === null || texture === PIXI.Texture.EMPTY;\r\n  }\r\n\r\n  public static stringIsNullOrEmpty(value: string): boolean {\r\n    return value === null || value === '';\r\n  }\r\n\r\n  public static hasInterface<T>(obj: any, propertyChecker: InterfaceLookup<T>): obj is T {\r\n    const properties = Object.keys(propertyChecker) as (keyof T)[];\r\n    return properties.every(prop => prop in obj);\r\n  }\r\n}\r\n\r\n\r\n//HACK: You can't check interfaces at rutnime in typescript so \r\n//we do a lookup on a manual set of properties that we expect to exist\r\nexport const ICollisionSystemBodyInterfaceLookup: InterfaceLookup<ICollisionSystemBody> = {\r\n  canCollisionBeChecked: true,\r\n};\r\n\r\ntype InterfaceLookup<T> = {\r\n  [P in keyof T]?: boolean;\r\n};","import * as PIXI from 'pixi.js';\r\nimport { GixiApplication } from \"../GixiApplication\";\r\nimport { SystemBase } from \"./base/SystemBase\";\r\nimport { ICollisionSystemBody } from '../interfaces/ICollisionSystemBody';\r\nimport { GixiUtility, ICollisionSystemBodyInterfaceLookup } from \"../GixiUtility\";\r\nimport { ISystemBase } from \"./base/SystemBase\";\r\nimport { ActorContainer } from '../ActorContainer';\r\n\r\n\r\n/**\r\n * \r\n */\r\nexport interface ICollisionSystem extends ISystemBase {\r\n\r\n    // Properties -----------------------------------\r\n    stageContainers: PIXI.Container[];\r\n\r\n    // Methods --------------------------------------\r\n    stageContainersCollidingWith(me: PIXI.Container): PIXI.Container[];\r\n}\r\n\r\n\r\n/**\r\n * CollisionSystem is responsible for detecting collisions between PIXI containers.\r\n * It extends the SystemBase class and provides methods to get colliding sprites.\r\n */\r\nexport class CollisionSystem extends SystemBase implements ICollisionSystem {\r\n\r\n    // Properties -------------------------------\r\n\r\n    // CHEAP TO CALL\r\n    public get stageContainers(): PIXI.Container[] {\r\n        return this._stageContainers;\r\n    }\r\n\r\n    // EXPENSIVE TO CALL\r\n    private stageContainersRefresh() {\r\n        this._stageContainers = this.stageContainersRefreshRecursive(this._app.app.stage);\r\n    }\r\n\r\n    // Fields -------------------------------\r\n    private _stageContainers!: PIXI.Container[];\r\n\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n        super(app);\r\n    }\r\n\r\n    public override async initializeAsync(): Promise<any> {\r\n        if (this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n        // Local\r\n        this._isInitialized = true;\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    /**\r\n     * Get all sprites that are colliding with the given sprite.\r\n     * @param me - The sprite to check collisions for.\r\n     * @returns An array of sprites that are colliding with the given sprite.\r\n     */\r\n    public stageContainersCollidingWith(me: PIXI.Container): PIXI.Container[] {\r\n\r\n        //TODO: Call this line much more rarely\r\n        //FOr example have the app call this only when addstage/removestage/addviewport/removeviewport\r\n        //or perhaps there is stage listener in pixi?\r\n        this.stageContainersRefresh();\r\n\r\n        //\r\n        const collisions: PIXI.Container[] =\r\n            this.getCollisionsInternal(me, this._stageContainers);\r\n\r\n        return collisions;\r\n    }\r\n\r\n    /**\r\n     * Recursively get all children of a container, including nested children.\r\n     * @param container - The container to get children from.\r\n     * @returns An array of all containers.\r\n     */\r\n    private stageContainersRefreshRecursive(container: PIXI.Container): PIXI.Container[] {\r\n        const result: PIXI.Container[] = [];\r\n        container.children.forEach(child => {\r\n            result.push(child as PIXI.Container);\r\n            if (child instanceof PIXI.Container && child.children.length > 0) {\r\n                result.push(...this.stageContainersRefreshRecursive(child));\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Internal Methods -----------------------------\r\n\r\n    /**\r\n     * Get all sprites from the given children that are colliding with the given sprite.\r\n     * @param me - The sprite to check collisions for.\r\n     * @param children - The children to check collisions against.\r\n     * @returns An array of sprites that are colliding with the given sprite.\r\n     */\r\n    private getCollisionsInternal(me: PIXI.Container, children: PIXI.Container[]): PIXI.Container[] {\r\n        return children.filter((child) => {\r\n\r\n            const hasICollisionSystemBody = GixiUtility.hasInterface<ICollisionSystemBody>(child, ICollisionSystemBodyInterfaceLookup);\r\n\r\n            return (\r\n                child !== me &&\r\n                hasICollisionSystemBody &&\r\n                child.canCollisionBeChecked &&\r\n                this.isCollidingWith(me, child as PIXI.Container)\r\n            );\r\n        }) as PIXI.Container[];\r\n    }\r\n\r\n\r\n    /**\r\n * Check if the given sprite is colliding with another sprite.\r\n * @param me - The sprite to check collisions for.\r\n * @param other - The other sprite to check collisions against.\r\n * @returns True if the sprites are colliding, false otherwise.\r\n */\r\n    private isCollidingWith(me: PIXI.Container, other: PIXI.Container): boolean {\r\n        const bounds1 = me.getBounds();\r\n        const bounds2 = other.getBounds();\r\n\r\n        return (\r\n            bounds1.x < bounds2.x + bounds2.width &&\r\n            bounds1.x + bounds1.width > bounds2.x &&\r\n            bounds1.y < bounds2.y + bounds2.height &&\r\n            bounds1.y + bounds2.height > bounds2.y\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n","import * as PIXI from 'pixi.js';\r\nimport { IInitializableAsync } from './interfaces/IInitializeAsync';\r\nimport { GixiApplication } from './GixiApplication';\r\nimport { IActor } from './interfaces/IActor';\r\nimport { IActorConfiguration } from './interfaces/IActorConfiguration';\r\n\r\n\r\n/**\r\n* Configuration\r\n*/\r\nexport interface ActorContainerConfiguration extends IActorConfiguration {\r\n\r\n}\r\n\r\nconst ActorContainerConfigurationDefault: ActorContainerConfiguration = {\r\n  canCollisionCheck: true,\r\n  isTickable: true,\r\n  isResizable: true\r\n}\r\n\r\n\r\n\r\nexport class ActorContainer extends PIXI.Container implements IInitializableAsync, IActor {\r\n\r\n  // Properties -----------------------------------\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public get configuration(): ActorContainerConfiguration {\r\n    return this._configuration;\r\n  }\r\n\r\n  public get canCollisionCheck(): boolean {\r\n    return this._canCollisionCheck;\r\n  }\r\n\r\n  public isChild(): boolean {\r\n    return this.parent !== null;\r\n  }\r\n\r\n  // Fields ---------------------------------------\r\n  private _isDestroyed: boolean = false;\r\n  protected _configuration: ActorContainerConfiguration;\r\n  protected _isInitialized: boolean = false;\r\n  protected _canCollisionCheck: boolean = true;\r\n  protected _app: GixiApplication;\r\n\r\n\r\n\r\n  // Initialization -------------------------------\r\n  constructor(app: GixiApplication,\r\n    configuration?: Partial<ActorContainerConfiguration>) {\r\n\r\n    super();\r\n    this._configuration = { ...ActorContainerConfigurationDefault, ...configuration };\r\n    this._app = app;\r\n\r\n    // Tick\r\n    if (this.configuration.isTickable) {\r\n      this._app.app.ticker.add(this.onTickInternal.bind(this));\r\n    }\r\n\r\n    // Resize\r\n    if (this.configuration.isResizable) {\r\n      this._app.addListener(GixiApplication.EVENT_RESIZE, this.onResizeInternal.bind(this));\r\n    }\r\n\r\n    // DO NOT CALL initializeAsync here. It is called by the child\r\n  }\r\n\r\n  public requireIsInitialized() {\r\n\r\n    if (!this.isInitialized) {\r\n      throw new Error('requireIsInitialized.');\r\n    }\r\n  }\r\n\r\n  public async initializeAsync(): Promise<any> {\r\n\r\n    if (this._isInitialized) {\r\n      return;\r\n    }\r\n\r\n    this._isInitialized = true;\r\n  }\r\n\r\n\r\n  // Override PIXI.Sprite's destroy method\r\n  public override destroy(options?: PIXI.DestroyOptions | boolean): void {\r\n\r\n    this.requireIsInitialized();\r\n\r\n    if (this._isDestroyed) return;\r\n\r\n    // Clean up\r\n    if (this.configuration.isTickable) {\r\n      this._app.app.ticker.remove(this.onTickInternal.bind(this));\r\n    }\r\n    if (this.configuration.isResizable) {\r\n      this._app.removeListener(GixiApplication.EVENT_RESIZE, this.onResizeInternal.bind(this));\r\n    }\r\n    this._isDestroyed = true;\r\n    super.destroy(options);\r\n  }\r\n\r\n  // Event Handlers -------------------------------\r\n  public onAdded() {\r\n    // Empty implementation to be overridden\r\n  }\r\n\r\n  public onRemoved() {\r\n    // Empty implementation to be overridden\r\n  }\r\n\r\n  public onResize(app: GixiApplication): void {\r\n    // Empty implementation to be overridden\r\n  }\r\n\r\n  public onTick(ticker: PIXI.Ticker): void {\r\n\r\n    // Empty implementation to be overridden\r\n    if (!this.canCollisionCheck) {\r\n      return;\r\n    }\r\n\r\n    const collisions = this._app.systems.collisionSystem.stageContainersCollidingWith(this);\r\n\r\n    if (collisions.length) {\r\n      this.onCollision(collisions);\r\n    };\r\n\r\n  }\r\n\r\n  protected onCollision(collisions: PIXI.Container[]): void {\r\n    // Empty implementation to be overridden\r\n  }\r\n\r\n  //TODO: remove these internals???\r\n  private onTickInternal(ticker: PIXI.Ticker): void {\r\n    if (this._isDestroyed) return;\r\n    this.onTick(ticker);\r\n  }\r\n\r\n  private onResizeInternal(app: GixiApplication): void {\r\n    if (this._isDestroyed) return;\r\n    this.onResize(app);\r\n  }\r\n\r\n\r\n}","import { GixiApplication } from \"../GixiApplication\";\r\nimport { ISystemBase } from \"./base/SystemBase\";\r\nimport { SystemBase } from \"./base/SystemBase\";\r\n\r\n\r\n/**\r\n * \r\n */\r\nexport interface IInputSystem extends ISystemBase {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Methods --------------------------------------\r\n    isKeyDown(keycode: string): boolean;\r\n    isKeyDownThisFrame(keycode: string): boolean;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Handles keyboard input and maintains the state of keys.\r\n */\r\nexport class InputSystem extends SystemBase implements IInputSystem {\r\n\r\n    // Fields ---------------------------------------\r\n    private _keyStateDictionary: Map<string, KeyState>;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n        super(app);\r\n\r\n        //TODO: Move this and all systems to use IInitializeAsync and move this into that init\r\n        this._keyStateDictionary = new Map();\r\n        window.addEventListener('keydown', this.onKeyDown.bind(this));\r\n        window.addEventListener('keyup', this.onKeyUp.bind(this));\r\n    }\r\n\r\n    public override async initializeAsync(): Promise<any> {\r\n\r\n        if (this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n\r\n        //console.log(`${(InputSystem).name}.initializeAsync()`)\r\n\r\n        //Local\r\n        this._isInitialized = true;\r\n\r\n    }\r\n\r\n    // Methods ------------------------------\r\n    /**\r\n     * Checks if the specified key is currently pressed down.\r\n     * @param key - The key to check.\r\n     * @returns True if the key is down, otherwise false.\r\n     */\r\n    public isKeyDown(key: string): boolean {\r\n        let keyState: KeyState = this.getKeyStateByKey(key);\r\n        return keyState.isDown;\r\n    }\r\n\r\n    /**\r\n     * Checks if the specified key was pressed down this frame.\r\n     * @param key - The key to check.\r\n     * @returns True if the key is down this frame, otherwise false.\r\n     */\r\n    public isKeyDownThisFrame(key: string): boolean {\r\n        let keyState: KeyState = this.getKeyStateByKey(key);\r\n\r\n        //NOTE: I tried a few ways to capture **ONE** moment of true here\r\n        //FInally this one works - srivello\r\n        let isDownThisFrame = keyState.isDownThisFrame;\r\n        keyState.isDownThisFrame = false;\r\n        return isDownThisFrame;\r\n    }\r\n\r\n\r\n    /**\r\n     * Handles the key down event and updates the key state.\r\n     * @param keyboardEvent - The keyboard event.\r\n     */\r\n    private onKeyDown(keyboardEvent: KeyboardEvent): void {\r\n        let keyState: KeyState = this.getKeyStateByKey(keyboardEvent.key);\r\n        if (!keyState.isDown) {\r\n            keyState.isDown = true;\r\n            keyState.isDownThisFrame = true;\r\n        }\r\n        else {\r\n            keyState.isDownThisFrame = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles the key up event and updates the key state.\r\n     * @param keyboardEvent - The keyboard event.\r\n     */\r\n    private onKeyUp(keyboardEvent: KeyboardEvent): void {\r\n        let keyState: KeyState = this.getKeyStateByKey(keyboardEvent.key);\r\n        keyState.isDown = false;\r\n        keyState.isDownThisFrame = false;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the key state for the specified key. If the key does not exist, a new KeyState is created and returned.\r\n     * @param key - The key to retrieve the state for.\r\n     * @returns The KeyState for the specified key.\r\n     */\r\n    private getKeyStateByKey(key: string): KeyState {\r\n        let keyState: KeyState | undefined = this._keyStateDictionary.get(key);\r\n        if (keyState == undefined) {\r\n            let newKeyState: KeyState = new KeyState();\r\n            this._keyStateDictionary.set(key, newKeyState);\r\n            return newKeyState;\r\n        }\r\n        return keyState;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of keys for the next frame.\r\n     */\r\n    public update() {\r\n        this._keyStateDictionary.forEach((keyState) => {\r\n            keyState.isDownThisFrame = false;\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the state of a key.\r\n */\r\nclass KeyState {\r\n    constructor() {\r\n        this.isDown = false;\r\n        this.isDownThisFrame = false;\r\n    }\r\n\r\n    public isDown: boolean;\r\n    public isDownThisFrame: boolean;\r\n}\r\n","import { Sound, sound } from \"@pixi/sound\";\r\nimport { GixiApplication } from \"../GixiApplication\";\r\nimport { SystemBase } from \"./base/SystemBase\";\r\nimport { ISystemBase } from \"./base/SystemBase\";\r\n\r\n\r\n/**\r\n * \r\n */\r\nexport interface IAudioSystem extends ISystemBase {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Methods --------------------------------------\r\n    play(filename: string): void;\r\n    playAsync(filename: string): Promise<any>;\r\n}\r\n\r\n/**\r\n * Handles keyboard input and maintains the state of keys.\r\n */\r\nexport class AudioSystem extends SystemBase implements IAudioSystem {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Fields ---------------------------------------\r\n    private _audioContextResumed: boolean = false;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n        super(app);\r\n\r\n    }\r\n\r\n    override async initializeAsync(): Promise<any> {\r\n\r\n        if (this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n        //console.log(`${(AudioSystem).name}.initializeAsync()`)\r\n        //Local\r\n        this._isInitialized = true;\r\n        this.setupAudioContextResume();\r\n\r\n    }\r\n\r\n    // Methods ------------------------------\r\n\r\n    // Set up the audio context to resume after a user gesture\r\n    private setupAudioContextResume() {\r\n        const resumeAudioContext = () => {\r\n            if (!this._audioContextResumed) {\r\n                const audioContext = sound.context.audioContext;\r\n                if (audioContext.state === 'suspended') {\r\n                    audioContext.resume().then(() => {\r\n                        this._audioContextResumed = true;\r\n                        console.log('Audio context resumed');\r\n                    }).catch((err) => {\r\n                        console.error('Failed to resume audio context:', err);\r\n                    });\r\n                } else {\r\n                    this._audioContextResumed = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        // Listen for any user interaction\r\n        window.addEventListener('click', resumeAudioContext, { once: true });\r\n        window.addEventListener('touchstart', resumeAudioContext, { once: true });\r\n        window.addEventListener('keydown', resumeAudioContext, { once: true });\r\n    }\r\n\r\n    /**\r\n     * Play a sound file.\r\n     * @param filename \r\n     */\r\n    public async play(filename: string) {\r\n        this.playAsync(filename);\r\n    }\r\n\r\n    /**\r\n     * Play a sound file.\r\n     * @param filename \r\n     */\r\n    public async playAsync(filename: string) {\r\n        if (!this._audioContextResumed) {\r\n            console.warn('Audio context not resumed yet. Cannot play sound.');\r\n            return;\r\n        }\r\n\r\n        // Play the sound when needed\r\n        let x: Sound = Sound.from({\r\n            url: filename,\r\n            preload: true,\r\n            autoPlay: false,\r\n        });\r\n\r\n        while (!x.isLoaded) {\r\n            await new Promise(resolve => setTimeout(resolve, 100));\r\n        }\r\n\r\n        x.speed = 1;\r\n        x.volume = 1;\r\n        x.play();\r\n    }\r\n}\r\n","import { Socket } from \"socket.io\";\r\nimport { GixiApplication } from \"../GixiApplication\";\r\nimport { ISystemBase } from \"./base/SystemBase\";\r\nimport { SystemBase } from \"./base/SystemBase\";\r\nimport { io } from 'socket.io-client';\r\n\r\n/**\r\n * \r\n */\r\nexport interface IMultiplayerSystem extends ISystemBase {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Methods --------------------------------------\r\n}\r\n\r\n\r\n/**\r\n * Handles keyboard input and maintains the state of keys.\r\n */\r\nexport class MultiplayerSystem extends SystemBase implements IMultiplayerSystem {\r\n\r\n    // Fields ---------------------------------------\r\n    public isDebug: boolean = false;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n        super(app);\r\n\r\n    }\r\n\r\n    public override async initializeAsync(): Promise<any> {\r\n\r\n        if (this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n        this.consoleLog(`initializeAsync()`)\r\n\r\n        //Local\r\n        this._isInitialized = true;\r\n\r\n\r\n\r\n        //TODO: Maybe use the MANAGER from Socket instead of just the SOCKET itself?\r\n        //https://socket.io/docs/v4/client-api/\r\n\r\n\r\n        const socket = io('http://localhost:3001');\r\n\r\n\r\n        socket.on('connect', () => {\r\n\r\n            this.consoleLog('Connected to server');\r\n\r\n            // Send a message to the server\r\n            socket.emit('message', 'Hello from client!');\r\n        });\r\n\r\n\r\n        // Listen for messages from the server\r\n        socket.on('message', (msg: string) => {\r\n            this.consoleLog('Message from server: ' + msg);\r\n        });\r\n\r\n        socket.on('disconnect', () => {\r\n            this.consoleLog('Disconnected from server');\r\n        });\r\n\r\n        socket.on('connection', (socket: Socket) => {\r\n\r\n            this.consoleLog('connection to socket: ' + socket.id);\r\n\r\n        });\r\n\r\n        socket.io.on(\"error\", (error) => {\r\n            this.consoleLog('error from socket: ' + error);\r\n        });\r\n\r\n        socket.io.on(\"ping\", () => {\r\n            this.consoleLog('ping from socket ');\r\n        });\r\n\r\n        socket.on('customEvent', (message: string, data: any) => {\r\n            this.consoleLog(message); // Output: \"Here is some arbitrary data:\"\r\n            //console.log(data);    // Output: { key: 'value', num: 42, isActive: true }\r\n        });\r\n    }\r\n\r\n\r\n\r\n    // Methods ------------------------------\r\n\r\n    private consoleLog(msg: string) {\r\n\r\n        if (!this.isDebug) {\r\n            return;\r\n\r\n        }\r\n        console.log(`[${(MultiplayerSystem).name}] ${msg}`);\r\n    }\r\n}","import { GixiApplication } from \"../GixiApplication\";\r\nimport { SystemBase } from \"./base/SystemBase\";\r\nimport { ISystemBase } from \"./base/SystemBase\";\r\nimport { Tilemap } from '../tilemap/Tilemap';\r\n\r\n\r\n/**\r\n * \r\n */\r\nexport interface ITilemapCollisionSystem extends ISystemBase {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Methods --------------------------------------\r\n    setTilemap(tilemap: Tilemap): any;\r\n\r\n    //TODO: Generalize this. Ex... something like \"anyTilesAtPositionHavePropertyOf(\"Collision\")\r\n    isCollision(x: number, y: number, width: number, height: number): boolean;\r\n}\r\n\r\n\r\n/**\r\n * TilemapCollisionSystem handles lookups for tilemap info\r\n */\r\nexport class TilemapCollisionSystem extends SystemBase implements ITilemapCollisionSystem {\r\n\r\n    // Properties -------------------------------\r\n\r\n    // Fields -------------------------------\r\n    private _tilemap!: Tilemap;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n        super(app);\r\n    }\r\n\r\n    public override async initializeAsync(): Promise<any> {\r\n        if (this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n        // Local\r\n        this._isInitialized = true;\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n    public setTilemap(tilemap: Tilemap): void {\r\n        this._tilemap = tilemap;\r\n    }\r\n\r\n    public isCollision(x: number, y: number, width: number, height: number): boolean {\r\n\r\n        if (!this._tilemap) {\r\n            throw new Error('TilemapCollisionSystem: Tilemap must be set first');\r\n        }\r\n        return this._tilemap.isCollision(x, y, width, height);\r\n    }\r\n\r\n    // Event Handlers -------------------------------\r\n}\r\n\r\n\r\n\r\n","import * as PIXI from 'pixi.js';\r\nimport { Viewport } from 'pixi-viewport';\r\nimport { EventEmitter } from 'events';\r\nimport { IInitializableAsync } from './interfaces/IInitializeAsync';\r\nimport { CollisionSystem, ICollisionSystem } from './systems/CollisionSystem';\r\nimport { ActorContainer } from './ActorContainer';\r\nimport { IInputSystem, InputSystem } from './systems/InputSystem';\r\nimport { AudioSystem, IAudioSystem } from './systems/AudioSystem';\r\nimport { IMultiplayerSystem, MultiplayerSystem } from './systems/MultiplayerSystem';\r\nimport { GixiText } from './GixiText';\r\nimport { ITilemapCollisionSystem, TilemapCollisionSystem } from './systems/TilemapCollisionSystem';\r\nimport { Tilemap } from './tilemap/Tilemap';\r\n\r\n/**\r\n * Configuration\r\n */\r\nexport interface GixiApplicationConfiguration {\r\n  widthInitial: number;\r\n  heightInitial: number;\r\n  backgroundColor: number;\r\n  minFPS: number,\r\n  maxFPS: number,\r\n  data: { [key: string]: any };\r\n}\r\n\r\nconst GixiApplicationConfigurationDefault: GixiApplicationConfiguration = {\r\n  widthInitial: 1920,\r\n  heightInitial: 1080,\r\n  minFPS: 1,\r\n  maxFPS: 240,\r\n  backgroundColor: 0x1099bb,\r\n  data: {}\r\n}\r\n\r\n\r\nclass Systems implements IInitializableAsync {\r\n\r\n  // Properties -----------------------------------\r\n  get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  // Fields ---------------------------------------\r\n  public tilemapCollisionSystem: ITilemapCollisionSystem;\r\n  public collisionSystem: ICollisionSystem;\r\n  public inputSystem: IInputSystem;\r\n  public audioSystem: IAudioSystem;\r\n  public multiplayerSystem: IMultiplayerSystem;\r\n  private _isInitialized: boolean = false;\r\n\r\n  // Initialization -------------------------------\r\n  constructor(app: GixiApplication) {\r\n    this.collisionSystem = new CollisionSystem(app);\r\n    this.tilemapCollisionSystem = new TilemapCollisionSystem(app);\r\n    this.inputSystem = new InputSystem(app);\r\n    this.audioSystem = new AudioSystem(app);\r\n    this.multiplayerSystem = new MultiplayerSystem(app);\r\n  }\r\n\r\n  public async initializeAsync(): Promise<any> {\r\n    return await Promise.all([\r\n      this.collisionSystem.initializeAsync(),\r\n      this.inputSystem.initializeAsync(),\r\n      this.audioSystem.initializeAsync(),\r\n      this.multiplayerSystem.initializeAsync()\r\n    ]);\r\n  }\r\n\r\n  requireIsInitialized() {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Systems are not initialized.');\r\n    }\r\n  }\r\n\r\n  // Methods -------------------------------\r\n}\r\n\r\n\r\n/**\r\n * Wrapper class for initializing and managing a PixiJS application.\r\n */\r\nexport class GixiApplication extends EventEmitter implements IInitializableAsync {\r\n\r\n\r\n\r\n  // Constants ------------------------------------\r\n  public static readonly EVENT_INITIALIZE_COMPLETE: string = 'initializeComplete';\r\n  public static readonly EVENT_INITIALIZE_ERROR: string = 'initializeError';\r\n  public static readonly EVENT_RESIZE: string = 'resize';\r\n\r\n\r\n  // Properties -----------------------------------\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public get isFullscreen(): boolean {\r\n    return this._isFullscreen;\r\n  }\r\n\r\n  public set isFullscreen(value: boolean) {\r\n\r\n    this._isFullscreen = value;\r\n\r\n    var elem = document.getElementById(this.app.canvas.id);\r\n\r\n    if (this._isFullscreen) {\r\n\r\n      if (elem?.requestFullscreen) {\r\n        elem?.requestFullscreen();\r\n      }\r\n\r\n    }\r\n    else {\r\n      document.fullscreenEnabled && document.exitFullscreen();\r\n    }\r\n  }\r\n\r\n  //TODO: Move to new SceneSystem class? = YES!\r\n  public reload() {\r\n    document.location.reload();\r\n  }\r\n\r\n  public get systems(): Systems {\r\n    return this._systems;\r\n  }\r\n\r\n  public get configuration(): GixiApplicationConfiguration {\r\n    return this._configuration;\r\n  }\r\n\r\n  // Fields ---------------------------------------\r\n  public app: PIXI.Application;\r\n  public viewport!: Viewport;\r\n  private _configuration: GixiApplicationConfiguration;\r\n  //\r\n  private _canvasId: string;\r\n  private _isInitialized = false;\r\n  private _systems: Systems;\r\n  private _isFullscreen: boolean = false;\r\n\r\n  // Initialization -------------------------------\r\n  constructor(\r\n    canvasId: string = 'pixi-application-canvas',\r\n    configuration?: Partial<GixiApplicationConfiguration>\r\n  ) {\r\n\r\n    /////////////////////////////\r\n    // Setup\r\n    /////////////////////////////\r\n    super();\r\n    this._canvasId = canvasId;\r\n\r\n\r\n    //TODO: The console logs out the renderer upon init. \r\n    //      Note its forever \"WebGL\". I want WebGPU. - srivello\r\n    this.app = new PIXI.Application<PIXI.WebGPURenderer<HTMLCanvasElement>>();\r\n    this._configuration = { ...GixiApplicationConfigurationDefault, ...configuration };\r\n    this._systems = new Systems(this);\r\n\r\n    // Every SuperSprite instance listens to App\r\n    // So this number must be >= to the number of SuperSprite instances\r\n    this.setMaxListeners(100);\r\n  }\r\n\r\n\r\n  /**\r\n   * Initializes the PixiJS application.\r\n   */\r\n  public async initializeAsync(): Promise<any> {\r\n    if (this._isInitialized) {\r\n      return;\r\n    }\r\n\r\n    this._isInitialized = true;\r\n\r\n    await this._systems.initializeAsync();\r\n\r\n    try {\r\n      await this.app.init({\r\n        canvas: document.getElementById(this._canvasId) as HTMLCanvasElement,\r\n        backgroundColor: this.configuration.backgroundColor,\r\n        width: this.configuration.widthInitial,\r\n        height: this.configuration.heightInitial,\r\n        resizeTo: window,\r\n\r\n\r\n        antialias: true,\r\n        backgroundAlpha: 1,\r\n        powerPreference: 'high-performance',\r\n\r\n        // FORCE WEBGPU - This works, but it throws errors (fixable?)\r\n        //preference: \"webgpu\",\r\n\r\n        // EVENTS\r\n        eventMode: 'passive',\r\n        eventFeatures: {\r\n\r\n          /** what is this? */\r\n          move: true, //try false after I get swipe working\r\n\r\n          /** disables the global move events which can be very expensive in large scenes */\r\n          globalMove: true, //try false after I get swipe working\r\n          click: true,\r\n          wheel: false\r\n        }\r\n\r\n      });\r\n\r\n      this.app.ticker.minFPS = this.configuration.minFPS;\r\n      this.app.ticker.maxFPS = this.configuration.maxFPS;\r\n\r\n      let possible: string = \"WebGL\";\r\n      if (navigator.gpu) {\r\n        possible = \"(WebGL, WebGPU)\";\r\n      }\r\n      console.log(`PIXI.Application.init() success! PixiJS v${PIXI.VERSION} ...\\nRendering Supported : ${possible}. Rendering Active : ${this.GetRendererTypeAsString(this.app.renderer.type)}.`);\r\n\r\n\r\n      /////////////////////////////\r\n      // Create Viewport\r\n      /////////////////////////////\r\n      this.viewport = new Viewport({\r\n        screenWidth: this.app.screen.width,\r\n        screenHeight: this.app.screen.height,\r\n        worldWidth: 3000,   //not sure\r\n        worldHeight: 3000,  //not sure\r\n\r\n        // the interaction module is important for wheel to work properly \r\n        // when renderer.view is placed or scaled\r\n        events: this.app.renderer.events\r\n      });\r\n\r\n      this.viewport.center = this.getScreenCenterpoint();\r\n\r\n      this.app.ticker.add((ticker) => {\r\n        this.viewport.update(ticker.deltaMS);\r\n      });\r\n\r\n\r\n      /////////////////////////////\r\n      this.emit(GixiApplication.EVENT_INITIALIZE_COMPLETE, this);\r\n      this.setupResizeHandling();\r\n      this.addToStage(this.viewport);\r\n      this.viewport.label = \"Viewport\"; //TODO: Why \"Et Viewport\"?\r\n\r\n    } catch (error) {\r\n      console.log(`PIXI.Application.init() failed! PixiJS v${PIXI.VERSION} with ${this.GetRendererTypeAsString(this.app.renderer.type)} `);\r\n\r\n      this.emit(GixiApplication.EVENT_INITIALIZE_ERROR, error);\r\n    }\r\n\r\n\r\n  }\r\n\r\n  public requireIsInitialized() {\r\n\r\n    if (!this.isInitialized) {\r\n      throw new Error('requireIsInitialized.');\r\n    }\r\n  }\r\n\r\n\r\n  // Methods ------------------------------\r\n  private GetRendererTypeAsString(type: number) {\r\n    let rendererType: string = \"Unknown\";\r\n    switch (type) {\r\n      case PIXI.RendererType.WEBGL:\r\n        rendererType = 'WebGL';\r\n        break;\r\n      case PIXI.RendererType.WEBGPU:\r\n        rendererType = 'WebGPU';\r\n        break;\r\n      case PIXI.RendererType.BOTH:\r\n        rendererType = 'BOTH';\r\n        break;\r\n      default:\r\n        rendererType = 'Unknown';\r\n        break;\r\n    }\r\n    return rendererType;\r\n  }\r\n\r\n  // Add to camera-controlled scene tree\r\n  public addToViewport(obj: PIXI.Container | PIXI.Sprite): any {\r\n\r\n    this.requireIsInitialized();\r\n\r\n    this.viewport.addChild(obj);\r\n\r\n    if (obj instanceof ActorContainer) {\r\n      obj.onAdded();\r\n    }\r\n\r\n\r\n    this.resize();\r\n  }\r\n\r\n  // Remove from camera-controlled scene tree\r\n  public removeFromViewport(obj: PIXI.Container | PIXI.Sprite): any {\r\n\r\n    this.requireIsInitialized();\r\n\r\n    this.viewport.removeChild(obj);\r\n\r\n    if (obj instanceof ActorContainer) {\r\n      obj.onRemoved();\r\n    }\r\n\r\n    this.resize();\r\n  }\r\n\r\n  // Add to basic scene tree\r\n  public addToStage(obj: PIXI.Container | PIXI.Sprite, parent?: PIXI.Sprite | ActorContainer): any {\r\n\r\n    this.requireIsInitialized();\r\n\r\n    if (parent == null) {\r\n      this.app.stage.addChild(obj);\r\n    } else {\r\n      parent.addChild(obj);\r\n    }\r\n\r\n    if (obj instanceof ActorContainer) {\r\n      obj.onAdded();\r\n    }\r\n\r\n    this.resize();\r\n  };\r\n\r\n\r\n  // Remove from basic scene tree\r\n  public removeFromStage(obj: PIXI.Container | PIXI.Sprite, parent?: PIXI.Sprite | ActorContainer): any {\r\n\r\n    this.requireIsInitialized();\r\n\r\n    if (parent == null) {\r\n      this.app.stage.removeChild(obj);\r\n    }\r\n    else {\r\n      parent.removeChild(obj);\r\n    }\r\n\r\n    if (obj instanceof ActorContainer) {\r\n      obj.onRemoved();\r\n    }\r\n\r\n    this.resize();\r\n  }\r\n\r\n\r\n  public resize = () => {\r\n\r\n    this.emit(GixiApplication.EVENT_RESIZE, this);\r\n  };\r\n\r\n  private setupResizeHandling() {\r\n\r\n    const resizeAfterDelay = () => {\r\n      setTimeout(this.resize, 100);\r\n    };\r\n\r\n    /////////////////////////////\r\n    // Observe window resize\r\n    /////////////////////////////\r\n    window.addEventListener('resize', this.resize);               //now\r\n    window.addEventListener('resize', resizeAfterDelay);          //and after delay. Robust.\r\n    window.addEventListener('orientationchange', this.resize);\r\n    window.addEventListener('orientationchange', resizeAfterDelay);\r\n    this.resize(); // Initial resize\r\n  }\r\n\r\n  public getScreenScaleCurrent(): PIXI.Point {\r\n\r\n    return new PIXI.Point(\r\n      this.app.screen.width / this.configuration.widthInitial,\r\n      this.app.screen.height / this.configuration.heightInitial\r\n    );\r\n  }\r\n\r\n\r\n\r\n  getScreenCenterpoint() {\r\n\r\n    return new PIXI.Point(\r\n      this.app.screen.width / 2,\r\n      this.app.screen.height / 2)\r\n  }\r\n\r\n  // Event Handlers -------------------------------\r\n}","import * as PIXI from 'pixi.js';\r\nimport { GixiApplication } from '../GixiApplication';\r\nimport { TilemapData } from '..';\r\nimport { Tilemap } from './Tilemap';\r\n\r\nexport class TilemapCollisionSystem {\r\n    private collisionMap!: boolean[][];\r\n    private _app: GixiApplication;\r\n    private _Tilemap: Tilemap;\r\n\r\n    constructor(app: GixiApplication, Tilemap: Tilemap) {\r\n        this._app = app;\r\n        this._Tilemap = Tilemap;\r\n    }\r\n\r\n    public async initializeAsync() {\r\n        this.collisionMap = this.createCollisionMap(this._Tilemap.tilemapData);\r\n    }\r\n\r\n    private createCollisionMap(tilemapData: TilemapData): boolean[][] {\r\n        if (!tilemapData.layers || !tilemapData.tilesets) {\r\n            throw new Error('Invalid tilemapData: layers or tilesets are missing');\r\n        }\r\n\r\n        const layers = tilemapData.layers;\r\n        const tilesets = tilemapData.tilesets;\r\n\r\n        // Initialize collision map with the dimensions of the tilemap\r\n        const collisionMap: boolean[][] = Array.from({ length: tilemapData.height }, () =>\r\n            Array(tilemapData.width).fill(false)\r\n        );\r\n\r\n        // Build a lookup map for IsCollision property\r\n        const collisionProperties: { [key: number]: boolean } = {};\r\n        tilesets.forEach((tileset) => {\r\n            if (tileset.tiles) {\r\n                tileset.tiles.forEach((tile) => {\r\n                    if (tile.properties) {\r\n                        tile.properties.forEach((property) => {\r\n                            if (property.name === \"IsCollision\") {\r\n                                collisionProperties[tileset.firstgid + tile.id] = property.value;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n\r\n            }\r\n        });\r\n\r\n        // Populate the collision map based on the tile data\r\n        layers.forEach((layer) => {\r\n            if (layer.type === \"tilelayer\" && layer.data) {\r\n                for (let y = 0; y < layer.height; y++) {\r\n                    for (let x = 0; x < layer.width; x++) {\r\n                        const tileIndex = layer.data[y * layer.width + x];\r\n                        if (collisionProperties[tileIndex]) {\r\n                            collisionMap[y][x] = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return collisionMap;\r\n    }\r\n\r\n    public isCollision(x: number, y: number, width: number, height: number): boolean {\r\n        const localPos = new PIXI.Point(x, y);\r\n        const globalPos = new PIXI.Point();\r\n        this._app.app.stage.toGlobal(localPos, globalPos);\r\n\r\n        const tileWidth = this._Tilemap.tilemapData.tilewidth;\r\n        const tileHeight = this._Tilemap.tilemapData.tileheight;\r\n\r\n        const startX = Math.floor((globalPos.x - this._Tilemap.x) / tileWidth);\r\n        const endX = Math.ceil((globalPos.x - this._Tilemap.x + width) / tileWidth);\r\n        const startY = Math.floor((globalPos.y - this._Tilemap.y) / tileHeight);\r\n        const endY = Math.ceil((globalPos.y - this._Tilemap.y + height) / tileHeight);\r\n\r\n        const localTileX = Math.floor(localPos.x / tileWidth);\r\n        const localTileY = Math.floor(localPos.y / tileHeight);\r\n        const globalTileX = Math.floor((globalPos.x - this._Tilemap.x) / tileWidth);\r\n        const globalTileY = Math.floor((globalPos.y - this._Tilemap.y) / tileHeight);\r\n\r\n        const tilemapGlobalPos = new PIXI.Point();\r\n        this._Tilemap.toGlobal(new PIXI.Point(0, 0), tilemapGlobalPos);\r\n\r\n        for (let tileY = startY; tileY < endY; tileY++) {\r\n            for (let tileX = startX; tileX < endX; tileX++) {\r\n                if (tileY >= 0 && tileY < this.collisionMap.length && tileX >= 0 && tileX < this.collisionMap[0].length) {\r\n                    //console.log(`Checking tile (${tileX}, ${tileY})`);\r\n                    if (this.collisionMap[tileY][tileX]) {\r\n                        //console.log(`Collision detected at tile (${tileX}, ${tileY})`);\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    //console.log(`Tile (${tileX}, ${tileY}) is out of bounds`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import * as PIXI from 'pixi.js';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { GixiUtility } from '../GixiUtility';\r\nimport { IInitializableAsync } from '../interfaces/IInitializeAsync';\r\nimport { ActorContainer, ActorContainerConfiguration } from '../ActorContainer';\r\nimport { TilemapCollisionSystem } from './TilemapCollisionSystem';\r\n\r\nexport interface TilemapData {\r\n  width: number;\r\n  height: number;\r\n  tilewidth: number;\r\n  tileheight: number;\r\n  layers: Layer[];\r\n  tilesets: Tileset[];\r\n}\r\n\r\nexport interface Layer {\r\n  type: string;\r\n  width: number;\r\n  height: number;\r\n  data?: number[];\r\n  objects?: any[];\r\n}\r\n\r\nexport interface Tileset {\r\n  firstgid: number;\r\n  tiles?: Tile[];\r\n}\r\n\r\nexport interface Tile {\r\n  id: number;\r\n  properties?: Property[];\r\n  type?: string;\r\n}\r\n\r\nexport interface Property {\r\n  name: string;\r\n  value: boolean;\r\n}\r\n\r\nexport interface TilemapItemData {\r\n  x: number;\r\n  y: number;\r\n  row: number;\r\n  column: number;\r\n  texture: PIXI.Texture;\r\n  layerType: LayerType;\r\n  type: string;\r\n}\r\n\r\n\r\nexport enum LayerType {\r\n  TileLayer = 'tilelayer',\r\n  ObjectGroup = 'objectgroup',\r\n}\r\n\r\nexport interface ITilemapItemFactory {\r\n  createTilemapItem(tilemap: Tilemap, tilemapItemData: TilemapItemData): Promise<PIXI.Container>;\r\n}\r\n\r\n\r\nexport class Tilemap extends ActorContainer implements IInitializableAsync {\r\n\r\n  // Properties -----------------------------------\r\n  get tilemapData(): TilemapData { return this._tilemapData; }\r\n\r\n  // Fields ---------------------------------------\r\n  private _tilemapDataUrl: string;\r\n  private _TilemapItemFactory: ITilemapItemFactory;\r\n  private _TilemapCollisionSystem: TilemapCollisionSystem;\r\n  private _tilemapData!: TilemapData;\r\n\r\n  // Initialization -------------------------------\r\n  constructor(app: GixiApplication, tilemapDataUrl: string, TilemapItemFactory: ITilemapItemFactory) {\r\n\r\n    const configuration: ActorContainerConfiguration = {\r\n      canCollisionCheck: false,\r\n      isTickable: false,\r\n      isResizable: false\r\n    }\r\n    super(app, configuration);\r\n\r\n    this._tilemapDataUrl = tilemapDataUrl;\r\n    this._TilemapItemFactory = TilemapItemFactory;\r\n    this._TilemapCollisionSystem = new TilemapCollisionSystem(this._app, this);\r\n\r\n\r\n    // OPTIMIZATION\r\n    //  https://pixijs.com/8.x/guides/advanced/render-groups\r\n    //    As you delve deeper into PixiJS, especially with version 8, \r\n    //    you'll encounter a powerful feature known as RenderGroups. Think \r\n    //    of RenderGroups as specialized containers within your scene graph \r\n    //    that act like mini scene graphs themselves. Here's what you need to\r\n    //    know to effectively use Render Groups in your projects:\r\n    this.isRenderGroup = true;\r\n\r\n    // INPUT\r\n    // https://pixijs.com/8.x/guides/components/interaction\r\n    this.interactive = false;\r\n    this.interactiveChildren = false;\r\n\r\n\r\n    //\r\n    this.label = (Tilemap).name;\r\n    this.position.set(0, 0);\r\n    this.scale.set(1);\r\n    this.isRenderGroup = true;\r\n  }\r\n  get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public override async initializeAsync() {\r\n\r\n\r\n    if (this.isInitialized) {\r\n      return;\r\n    }\r\n    await super.initializeAsync();\r\n    this._isInitialized = true;\r\n\r\n    if (GixiUtility.stringIsNullOrEmpty(this._tilemapDataUrl)) {\r\n      throw new Error(`Tilemap.initializeAsync() file missing error. tilemapDataUrl = \"${this._tilemapDataUrl}\"`);\r\n    }\r\n\r\n    if (!this._tilemapDataUrl.endsWith(\".tmj\")) {\r\n      throw new Error(`Tilemap.initializeAsync() file extension error. tilemapDataUrl = \"${this._tilemapDataUrl}\"`);\r\n    }\r\n\r\n    let response!: Response;\r\n    try {\r\n      response = await fetch(this._tilemapDataUrl);\r\n    }\r\n    catch (e) {\r\n      throw new Error(`Tilemap.initializeAsync() fetch error. tilemapDataUrl = \"${this._tilemapDataUrl}\"`);\r\n    }\r\n\r\n    try {\r\n      this._tilemapData = await response.json();\r\n    }\r\n    catch (e) {\r\n      throw new Error(`Tilemap.initializeAsync() json error. tilemapDataUrl = \"${this._tilemapDataUrl}\"`);\r\n    }\r\n\r\n    const tilesetPromises = this._tilemapData.tilesets.map((tileset: any) => {\r\n      const imageUrl = tileset.image.replace('../', 'assets/');\r\n      return PIXI.Assets.load(imageUrl).then(() => {\r\n        return { ...tileset, texture: PIXI.Texture.from(imageUrl) };\r\n      });\r\n    });\r\n\r\n\r\n    const tilesets = await Promise.all(tilesetPromises);\r\n\r\n    for (const layer of this._tilemapData.layers) {\r\n      if (layer.type === LayerType.TileLayer) {\r\n        await this.processTileLayer(layer, tilesets);\r\n      } else if (layer.type === LayerType.ObjectGroup && layer.objects) {\r\n        await this.processObjectLayer(layer, tilesets);\r\n      }\r\n    }\r\n\r\n    this._TilemapCollisionSystem.initializeAsync();\r\n  }\r\n\r\n  requireIsInitialized() {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  // Methods ------------------------------\r\n  private async processTileLayer(layer: Layer, tilesets: any[]) {\r\n    for (let row = 0; row < layer.height; row++) {\r\n      for (let column = 0; column < layer.width; column++) {\r\n        const tileIndex = layer.data ? layer.data[row * layer.width + column] : 0;\r\n        if (tileIndex > 0) {\r\n          const tileset = this.getTilesetForTile(tileIndex, tilesets);\r\n          if (tileset) {\r\n            const localTileIndex = tileIndex - tileset.firstgid;\r\n            const tileX = (localTileIndex % tileset.columns) * tileset.tilewidth;\r\n            const tileY = Math.floor(localTileIndex / tileset.columns) * tileset.tileheight;\r\n\r\n            const rectangle = new PIXI.Rectangle(tileX, tileY, tileset.tilewidth, tileset.tileheight);\r\n            const tileTexture = new PIXI.Texture({\r\n              source: tileset.texture.source,\r\n              frame: rectangle\r\n            });\r\n\r\n            const tilemapItemData: TilemapItemData = {\r\n              x: column * tileset.tilewidth,\r\n              y: row * tileset.tileheight,\r\n              row: row,\r\n              column: column,\r\n              texture: tileTexture,\r\n              layerType: LayerType.TileLayer,\r\n              type: this.getTileType(tileset, localTileIndex) || \"\"\r\n            };\r\n\r\n            const sprite = await this._TilemapItemFactory.createTilemapItem(this, tilemapItemData);\r\n            sprite.label = `Tile (${row.toString().padStart(2, '0')},${column.toString().padStart(2, '0')})`;\r\n\r\n            sprite.x = tilemapItemData.x;\r\n            sprite.y = tilemapItemData.y;\r\n            this.addChild(sprite);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async processObjectLayer(layer: Layer, tilesets: any[]) {\r\n    for (const object of layer.objects!) {\r\n      const tileset = this.getTilesetForTile(object.gid, tilesets);\r\n      if (tileset) {\r\n        const localTileIndex = object.gid - tileset.firstgid;\r\n        const tileX = (localTileIndex % tileset.columns) * tileset.tilewidth;\r\n        const tileY = Math.floor(localTileIndex / tileset.columns) * tileset.tileheight;\r\n\r\n        const rectangle = new PIXI.Rectangle(tileX, tileY, tileset.tilewidth, tileset.tileheight);\r\n        const tileTexture = new PIXI.Texture({\r\n          source: tileset.texture.source,\r\n          frame: rectangle\r\n        });\r\n\r\n        let typeResult: string = \"\"; //ok value\r\n        let typePrimary = object.type; //BUG: THis is never populated. Its backup. Ok for now\r\n        let typeBackup = this.getTileType(tileset, localTileIndex)?.toString();\r\n\r\n        if (!GixiUtility.stringIsNullOrEmpty(typePrimary)) {\r\n          typeResult = typePrimary;\r\n        }\r\n        else if (typeBackup != null && !GixiUtility.stringIsNullOrEmpty(typeBackup)) {\r\n          typeResult = typeBackup;\r\n        }\r\n\r\n        //this means its not in a grid since objects can be anywhere\r\n        const unsetValue = -1;\r\n\r\n        const tilemapItemData: TilemapItemData = {\r\n          x: object.x,\r\n          y: object.y - tileset.tileheight,\r\n          row: unsetValue,\r\n          column: unsetValue,\r\n          texture: tileTexture,\r\n          layerType: LayerType.ObjectGroup,\r\n          type: typeResult\r\n        };\r\n\r\n        const sprite = await this._TilemapItemFactory.createTilemapItem(this, tilemapItemData);\r\n        sprite.label = `Object (${object.id})`;\r\n\r\n        sprite.x = tilemapItemData.x;\r\n        sprite.y = tilemapItemData.y;\r\n\r\n        this.addChild(sprite);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Event Handlers -------------------------------\r\n  public isCollision(x: number, y: number, width: number, height: number): boolean {\r\n    return this._TilemapCollisionSystem.isCollision(x, y, width, height);\r\n  }\r\n\r\n  public override async onAdded() {\r\n    await this.initializeAsync();\r\n  }\r\n\r\n  private getTilesetForTile(tileIndex: number, tilesets: any[]): any {\r\n    for (let i = tilesets.length - 1; i >= 0; i--) {\r\n      if (tileIndex >= tilesets[i].firstgid) {\r\n        return tilesets[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public override onRemoved(): void {\r\n    while (this.children.length > 0) {\r\n      const child = this.removeChildAt(0);\r\n      if (child instanceof PIXI.Sprite) {\r\n        child.destroy({ children: true, texture: true });\r\n      }\r\n    }\r\n  }\r\n\r\n  public override onResize(app: GixiApplication): void {\r\n    // Handle resizing logic\r\n  }\r\n\r\n  public override onTick(ticker: PIXI.Ticker): void {\r\n    // Handle tick updates\r\n  }\r\n\r\n  private getTileType(tileset: Tileset, tileIndex: number): string | undefined {\r\n    if (!tileset.tiles) return undefined;\r\n    const tile = tileset.tiles.find(t => t.id === tileIndex);\r\n    return tile?.type;\r\n  }\r\n}","import { ActorContainer, ActorContainerConfiguration } from \"./ActorContainer\";\r\nimport { GixiApplication } from \"./GixiApplication\";\r\nimport { IActor } from \"./interfaces/IActor\";\r\nimport { IInitializableAsync } from \"./interfaces/IInitializeAsync\";\r\nimport * as PIXI from 'pixi.js';\r\n\r\n/**\r\n * Configuration\r\n */\r\nexport interface GixiTextConfiguration extends ActorContainerConfiguration {\r\n    textStyle: PIXI.TextStyle,\r\n}\r\n\r\nconst GixiTextConfigurationDefault: GixiTextConfiguration = {\r\n    textStyle: new PIXI.TextStyle(),\r\n    canCollisionCheck: false,\r\n    isTickable: true,\r\n    isResizable: true\r\n}\r\n\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class GixiText extends ActorContainer implements IInitializableAsync, IActor {\r\n\r\n\r\n    // Properties -----------------------------------\r\n    public override get configuration(): GixiTextConfiguration {\r\n        return this._configuration as GixiTextConfiguration;\r\n    }\r\n\r\n    public get textString(): string {\r\n        return this._text.text;\r\n    }\r\n\r\n    public set textString(value: string) {\r\n        this._text.text = value;\r\n\r\n        // Some resizing may depend on string length, so call again here\r\n        this.onResize(this._app);\r\n    }\r\n\r\n    // Fields ---------------------------------------\r\n    protected _text!: PIXI.Text\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, text: string, configuration?: Partial<GixiTextConfiguration>) {\r\n\r\n        super(app, { ...GixiTextConfigurationDefault, ...configuration });\r\n\r\n        const textOptions: PIXI.TextOptions = {\r\n            style: this.configuration.textStyle,\r\n            resolution: 2 // TODO: Best value? Ensure text is sharp\r\n        };\r\n\r\n        this._text = new PIXI.Text(textOptions);\r\n        this.addChild(this._text);\r\n\r\n        // Initialize\r\n        this.initializeAsync();\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (GixiText).name;\r\n        this._text.text = text;\r\n\r\n    }\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // Local\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    public override onTick(ticker: PIXI.Ticker): void {\r\n\r\n        // Super\r\n        super.onTick(ticker);\r\n\r\n\r\n        // Local\r\n        //Do any additional things here\r\n\r\n    }\r\n}\r\n\r\n","import { GixiApplication } from \"@src/scripts/client/gixi/GixiApplication\";\r\nimport { GixiText } from \"@src/scripts/client/gixi/GixiText\";\r\n\r\nexport class InstructionsText extends GixiText {\r\n\r\n    // Fields ---------------------------------------\r\n\r\n    // Initialization -------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n    public override onResize(app: GixiApplication): void {\r\n\r\n        //UPDATE POSITION\r\n        this.x = app.configuration.data.screenUIMarginX;\r\n        this.y = app.configuration.data.screenUIMarginY;\r\n\r\n        //HACK: UPDATE SIZE\r\n        this._text.style.fontSize = 15 + 7 / app.app.renderer.resolution\r\n\r\n\r\n    }\r\n\r\n}\r\n","import { GixiApplication } from \"@src/scripts/client/gixi/GixiApplication\";\r\nimport { GixiText } from \"@src/scripts/client/gixi/GixiText\";\r\n\r\nexport class ScoreText extends GixiText {\r\n\r\n    // Fields ---------------------------------------\r\n\r\n    // Initialization -------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n    public override onResize(app: GixiApplication): void {\r\n\r\n        //UPDATE POSITION\r\n        this.x = app.app.screen.width - this.width - app.configuration.data.screenUIMarginX;\r\n        this.y = app.configuration.data.screenUIMarginY;\r\n\r\n        //HACK: UPDATE SIZE\r\n        this._text.style.fontSize = 15 + 7 / app.app.renderer.resolution\r\n\r\n    }\r\n}\r\n","import { ActorContainer, ActorContainerConfiguration } from './ActorContainer';\r\nimport { GixiApplication } from './GixiApplication';\r\nimport { IActor } from './interfaces/IActor';\r\nimport { IInitializableAsync } from './interfaces/IInitializeAsync';\r\nimport { GixiUtility } from './GixiUtility';\r\nimport * as PIXI from 'pixi.js';\r\nimport { GlowFilter } from 'pixi-filters';\r\n\r\n\r\n\r\n//NOTE: I put this class witin the same file as ActorAnimated \r\n//so I can NOT export it (to hide it from direct use). Needed? Not sure.\r\nclass MultiAnimatedSprite {\r\n\r\n    // Fields ---------------------------------------\r\n    private _animationNameToAnimatedSprite: Map<string, PIXI.AnimatedSprite>;\r\n    private _textureImageURL: string;\r\n    private _spriteSheetURL: string;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(newTextureImageURL: string, newSpriteSheetURL: string) {\r\n        this._textureImageURL = newTextureImageURL;\r\n        this._spriteSheetURL = newSpriteSheetURL;\r\n        this._animationNameToAnimatedSprite = new Map();\r\n    }\r\n\r\n    // Methods ------------------------------\r\n    public async initializeAndReparent(app: GixiApplication, parent: PIXI.Container) {\r\n\r\n\r\n        const spriteSheetAtlasResponse = await fetch(this._spriteSheetURL);\r\n        const spriteSheetAtlas = await spriteSheetAtlasResponse.json();\r\n        await PIXI.Assets.load(this._textureImageURL);\r\n        const texture = PIXI.Texture.from(this._textureImageURL);\r\n        const spriteSheet = new PIXI.Spritesheet(texture, spriteSheetAtlas);\r\n        await spriteSheet.parse();\r\n\r\n        const size = new PIXI.Point(\r\n            spriteSheetAtlas.meta.size.w,\r\n            spriteSheetAtlas.meta.size.h\r\n        )\r\n\r\n        for (const [animationName, textures] of Object.entries(spriteSheet.animations)) {\r\n            this._animationNameToAnimatedSprite.set(animationName, new PIXI.AnimatedSprite(textures));\r\n        }\r\n\r\n        this._animationNameToAnimatedSprite.forEach((value: PIXI.AnimatedSprite, key: string) => {\r\n\r\n            //NOTE: The parent center and/or the value center may not be proper\r\n            //TODO: Go to index.ts and try to put a coin at a specific world position and then be sure it looks good\r\n            value.setSize(size.x, size.y);\r\n            value.label = (MultiAnimatedSprite).name;\r\n\r\n\r\n\r\n            value.anchor.set(0.5, 0.5);\r\n            parent.addChild(value);\r\n        });\r\n    }\r\n\r\n    public play(animationName: string, animationSpeed: number) {\r\n        const animatedSprite: PIXI.AnimatedSprite | undefined = this._animationNameToAnimatedSprite.get(animationName);\r\n        if (animatedSprite == undefined) {\r\n            throw new Error(\"Trying to play unknown animation with animationName=\" + animationName);\r\n        }\r\n\r\n        animatedSprite.animationSpeed = animationSpeed;\r\n        animatedSprite.play();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Configuration\r\n */\r\nexport interface ActorAnimatedConfiguration extends ActorContainerConfiguration {\r\n}\r\n\r\nconst ActorAnimatedConfigurationDefault: ActorAnimatedConfiguration = {\r\n    canCollisionCheck: true,\r\n    isTickable: true,\r\n    isResizable: true\r\n}\r\n\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class ActorAnimated extends ActorContainer implements IInitializableAsync, IActor {\r\n\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Fields ---------------------------------------\r\n    protected _multiAnimatedSprite!: MultiAnimatedSprite;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<ActorAnimatedConfiguration>) {\r\n\r\n        super(app, { ...ActorAnimatedConfigurationDefault, ...configuration });\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (ActorAnimated).name;\r\n\r\n        this.initializeAsync();\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        //TODO:\r\n        //1. Populate ActorAnimatedConfiguration above\r\n        //      with whatever is needed to pass into the constructor.\r\n        //      (See how ActorStatic does it.)\r\n        //2. Do some error checking here \r\n        //      (See how ActorStatic does it.)\r\n        //3. Update this snippet below as needed. Done!    \r\n        const animatedTextureURL = 'assets/images/AnimatedCoin/animated_coin.png';\r\n        const animatedTextureJSONURL = 'assets/images/AnimatedCoin/animated_coin.json';\r\n        this._multiAnimatedSprite = new MultiAnimatedSprite(animatedTextureURL, animatedTextureJSONURL);\r\n        await this._multiAnimatedSprite.initializeAndReparent(this._app, this);\r\n        this._multiAnimatedSprite.play('Gold', 0.2);\r\n\r\n\r\n        // Local\r\n        //Do any additional initialization here\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    public override onTick(ticker: PIXI.Ticker): void {\r\n\r\n        // Super\r\n        super.onTick(ticker);\r\n\r\n\r\n        // Local\r\n        //Do any additional things here\r\n\r\n    }\r\n}\r\n\r\n","import { Action, Actions, Interpolations } from \"pixi-actions\";\r\nimport { Container } from 'pixi.js';\r\n\r\n/**\r\n * Common functionality\r\n */\r\nclass Animations {\r\n\r\n  // Properties -----------------------------------\r\n\r\n  // Fields ---------------------------------------\r\n\r\n  // Methods --------------------------------------\r\n  spinAndShrink(target: Container, delayMs: number, durationMs: number, onStart: () => void, onComplete: () => void): Action {\r\n\r\n    let action = Actions.sequence(\r\n\r\n      Actions.delay(delayMs),\r\n      Actions.runFunc(() => {\r\n        onStart();\r\n      }),\r\n      Actions.parallel(\r\n\r\n        Actions.rotateTo(\r\n          target,\r\n          1,\r\n          durationMs,\r\n          Interpolations.smooth2),\r\n\r\n        Actions.scaleTo(\r\n          target,\r\n          0,\r\n          0,\r\n          durationMs,\r\n          Interpolations.smooth2),\r\n\r\n      ),\r\n      Actions.runFunc(() => {\r\n        onComplete();\r\n\r\n      }),\r\n\r\n    );\r\n    return action;\r\n\r\n  }\r\n\r\n\r\n  riseAndGrow(target: Container, delayMs: number, durationMs: number, onStart: () => void, onComplete: () => void): Action {\r\n\r\n    let action = Actions.sequence(\r\n\r\n      Actions.delay(delayMs),\r\n      Actions.runFunc(() => {\r\n        onStart();\r\n      }),\r\n      Actions.parallel(\r\n\r\n        Actions.moveTo(\r\n          target,\r\n          target.x,\r\n          target.y - target.height,\r\n          durationMs,\r\n          Interpolations.smooth2),\r\n\r\n        Actions.scaleTo(\r\n          target,\r\n          2,\r\n          2,\r\n          durationMs,\r\n          Interpolations.smooth2),\r\n\r\n      ),\r\n      Actions.runFunc(() => {\r\n        onComplete();\r\n      })\r\n\r\n    );\r\n\r\n    return action;\r\n\r\n  }\r\n\r\n};\r\n\r\n\r\n/**\r\n * Common functionality\r\n */\r\nexport class TreasureHunter2DConstants {\r\n\r\n  // Properties -----------------------------------\r\n  public static Animations = new Animations();\r\n\r\n  // Fields ---------------------------------------\r\n\r\n  // Methods --------------------------------------\r\n};","import { ActorAnimatedConfiguration } from '@src/scripts/client/gixi';\r\nimport { ActorAnimated } from '@src/scripts/client/gixi/ActorAnimated';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { ICollisionSystemBody } from '@src/scripts/client/gixi/interfaces/ICollisionSystemBody';\r\nimport { Actions, Interpolations } from 'pixi-actions';\r\nimport { DropShadowFilter, GlowFilter } from 'pixi-filters';\r\nimport { TreasureHunter2DConstants } from '../../TreasureHunter2DConstants';\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class CoinTilemapObject extends ActorAnimated implements ICollisionSystemBody {\r\n\r\n\r\n    // Properties -----------------------------------\r\n    public get canCollisionBeChecked(): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n    // Fields ---------------------------------------\r\n\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication) {\r\n\r\n        const configuration: ActorAnimatedConfiguration = {\r\n            canCollisionCheck: false,\r\n            isTickable: false,\r\n            isResizable: false\r\n        }\r\n\r\n        super(app, configuration);\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (CoinTilemapObject).name;\r\n\r\n    }\r\n\r\n    public whatever() {\r\n        this.isCollected = true;\r\n        this.destroyAfterAnimation();\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // OPTIONAL: Try these - https://pixijs.io/filters/\r\n        this.filters = [\r\n            //new GlowFilter({ distance: 1, outerStrength: 1, innerStrength: 1, color: 0xffff00 }),\r\n            new DropShadowFilter({ blur: 1, alpha: 0.5, quality: 3, resolution: 2 }) //\r\n        ];\r\n\r\n        // Local\r\n        //Do any additional initialization here\r\n\r\n    }\r\n\r\n\r\n    // Methods --------------------------------------\r\n\r\n\r\n    public destroyAfterAnimation() {\r\n\r\n        let action1 = TreasureHunter2DConstants.Animations.riseAndGrow(\r\n            this,\r\n            0,\r\n            20,\r\n            () => {\r\n                // onStart\r\n                this._app.systems.audioSystem.play(\"./assets/audio/Chime01.mp3\");\r\n            },\r\n            () => {\r\n\r\n                // onComplete\r\n                this.destroy();\r\n            }\r\n\r\n        );\r\n\r\n        action1.play();\r\n\r\n    }\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    //TODO: Rethink what and where this should be\r\n    public isCollected = false;\r\n    public collect() {\r\n\r\n        if (this.isCollected) {\r\n            return;\r\n        }\r\n        this.isCollected = true;\r\n        this.destroyAfterAnimation();\r\n    }\r\n\r\n}\r\n\r\n\r\n","import { ActorContainer, ActorContainerConfiguration } from './ActorContainer';\r\nimport { GixiApplication } from './GixiApplication';\r\nimport { IActor } from './interfaces/IActor';\r\nimport { IInitializableAsync } from './interfaces/IInitializeAsync';\r\nimport { GixiUtility } from './GixiUtility';\r\nimport * as PIXI from 'pixi.js';\r\n\r\n/**\r\n * Configuration\r\n */\r\nexport interface ActorStaticConfiguration extends ActorContainerConfiguration {\r\n    textureUrl: string;\r\n    texture: PIXI.Texture;\r\n}\r\n\r\nconst ActorStaticConfigurationDefault: ActorStaticConfiguration = {\r\n    textureUrl: '',\r\n    texture: PIXI.Texture.EMPTY,\r\n    canCollisionCheck: true,\r\n    isTickable: true,\r\n    isResizable: true\r\n}\r\n\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class ActorStatic extends ActorContainer implements IInitializableAsync, IActor {\r\n\r\n\r\n    // Properties -----------------------------------\r\n    public override get configuration(): ActorStaticConfiguration {\r\n        return this._configuration as ActorStaticConfiguration;\r\n    }\r\n\r\n    // Fields ---------------------------------------\r\n    protected _sprite!: PIXI.Sprite;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<ActorStaticConfiguration>) {\r\n\r\n        super(app, { ...ActorStaticConfigurationDefault, ...configuration });\r\n\r\n\r\n        if (!GixiUtility.textureIsNullOrEmpty(this.configuration?.texture) &&\r\n            !GixiUtility.stringIsNullOrEmpty(this.configuration?.textureUrl)) {\r\n            throw new Error(\"You cannot set both texture and textureUrl in the configuration\");\r\n        }\r\n\r\n        this.initializeAsync();\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (ActorStatic).name;\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        if (!GixiUtility.textureIsNullOrEmpty(this.configuration?.texture)) {\r\n            this._sprite = new PIXI.Sprite(this.configuration?.texture);\r\n        }\r\n        else if (!GixiUtility.stringIsNullOrEmpty(this.configuration?.textureUrl)) {\r\n            await PIXI.Assets.load([this.configuration.textureUrl]);\r\n            const texture: PIXI.Texture = PIXI.Texture.from(this.configuration.textureUrl);\r\n            this._sprite = new PIXI.Sprite(texture);\r\n        }\r\n\r\n        if (this._sprite) {\r\n            this._sprite.label = this.label;\r\n            this.addChild(this._sprite);\r\n            this._sprite.anchor.set(0.5, 0.5);\r\n        }\r\n\r\n\r\n        // Local\r\n        //Do any additional initialization here\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    public override onTick(ticker: PIXI.Ticker): void {\r\n\r\n        // Super\r\n        super.onTick(ticker);\r\n\r\n\r\n        // Local\r\n        //Do any additional things here\r\n\r\n    }\r\n}\r\n\r\n","import { ActorStatic, ActorStaticConfiguration } from '@src/scripts/client/gixi/ActorStatic';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { Actions, Interpolations } from 'pixi-actions';\r\nimport { DropShadowFilter } from 'pixi-filters';\r\nimport { Ticker } from 'pixi.js';\r\nimport { ICollisionSystemBody } from '../../../../gixi/interfaces/ICollisionSystemBody';\r\nimport { TreasureHunter2DConstants } from '../../TreasureHunter2DConstants';\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class ChestTilemapObject extends ActorStatic implements ICollisionSystemBody {\r\n\r\n    // Properties -----------------------------------\r\n    public get canCollisionBeChecked(): boolean {\r\n        return true;\r\n    }\r\n\r\n    // Fields ---------------------------------------\r\n\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<ActorStaticConfiguration>) {\r\n\r\n        if (configuration) {\r\n            configuration.canCollisionCheck = false;\r\n        }\r\n\r\n\r\n        super(app, configuration);\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (ChestTilemapObject).name;\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        this.filters = [\r\n            new DropShadowFilter({ blur: 1, alpha: 0.5, quality: 3, resolution: 2 })\r\n        ];\r\n\r\n        // Local\r\n        // Do any additional initialization here\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n    public override onTick(ticker: Ticker): void {\r\n\r\n        // Super\r\n        super.onTick(ticker);\r\n\r\n        // Local\r\n        this.rotation += 0.01 * ticker.deltaTime;\r\n    }\r\n\r\n    private destroyAfterAnimation() {\r\n\r\n        let action1 = TreasureHunter2DConstants.Animations.spinAndShrink(\r\n            this,\r\n            0,\r\n            20,\r\n            () => {\r\n                // onStart\r\n                this._app.systems.audioSystem.play(\"./assets/audio/Chime02.mp3\");\r\n            },\r\n            () => {\r\n\r\n                // onComplete\r\n                this.destroy();\r\n            }\r\n\r\n        );\r\n\r\n        action1.play();\r\n\r\n    }\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    //TODO: Rethink what and where this should be\r\n    public isCollected = false;\r\n    public collect() {\r\n\r\n        if (this.isCollected) {\r\n            return;\r\n        }\r\n        this.isCollected = true;\r\n        this.destroyAfterAnimation();\r\n    }\r\n\r\n}\r\n","import * as PIXI from 'pixi.js';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { DropShadowFilter } from 'pixi-filters';\r\nimport { CoinTilemapObject } from './tileMap/tileMapObjects/CoinTilemapObject';\r\nimport { ChestTilemapObject } from './tileMap/tileMapObjects/ChestTilemapObject';\r\nimport { ActorStatic, ActorStaticConfiguration } from '../../gixi/ActorStatic';\r\nimport { Tilemap } from '../../gixi/tilemap/Tilemap';\r\nimport { ICollisionSystemBody } from '../../gixi/interfaces/ICollisionSystemBody';\r\nimport { ITreasurHunterData } from '../..';\r\n\r\n/**\r\n * Configuration\r\n */\r\nexport interface PlayerConfiguration extends ActorStaticConfiguration {\r\n}\r\n\r\nconst PlayerConfigurationDefault: PlayerConfiguration = {\r\n    textureUrl: '',\r\n    texture: PIXI.Texture.EMPTY,\r\n    canCollisionCheck: true,\r\n    isTickable: true,\r\n    isResizable: true\r\n}\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class Player extends ActorStatic implements ICollisionSystemBody {\r\n\r\n\r\n    // Properties -----------------------------------\r\n    public get canCollisionBeChecked(): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n    // Fields ---------------------------------------\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<PlayerConfiguration>) {\r\n\r\n        super(app, { ...PlayerConfigurationDefault, ...configuration });\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (Player).name;\r\n\r\n\r\n        //TEST\r\n        //TODO: Update InputSystem to take screen-swipes instead of player-taps\r\n        this.on('pointerdown', (event) => {\r\n            this.position.x += 10;\r\n        });\r\n        this.eventMode = 'static';\r\n\r\n    }\r\n\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // OPTIONAL: Try these - https://pixijs.io/filters/\r\n        this._sprite.filters = [\r\n            new DropShadowFilter({ blur: 1, alpha: 0.5, quality: 3, resolution: 2 })\r\n        ];\r\n\r\n        // Local\r\n        //Do any additional initialization here\r\n        this._sprite.anchor.set(0, 0);\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n\r\n    //TODO: Utilize this to block movement\r\n    private isCollisionWithTilemap(x: number, y: number): boolean {\r\n\r\n        //show all 4 values in the log string\r\n        const width = 32;\r\n        const height = 32;\r\n        const isCollision = this._app.systems.tilemapCollisionSystem.isCollision(x, y, width, height);\r\n\r\n        // Internally the map uses globals, so we do NOT need to convert\r\n        //let globalPos = this.toGlobal(this.position);\r\n\r\n        if (isCollision) {\r\n            //console.log(`isCollisionWithTilemap (x=${x}, y=${y}) = ${isCollision}`);\r\n        }\r\n        else {\r\n            //console.log(`isCollisionWithTilemap (x=${x}, y=${y}) = ${isCollision}`);\r\n        }\r\n\r\n\r\n        return isCollision;\r\n\r\n    }\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    public override onTick(ticker: PIXI.Ticker): void {\r\n\r\n        super.onTick(ticker);\r\n\r\n        let moveVector: PIXI.Point = new PIXI.Point(0, 0);\r\n\r\n        //TODO: Change to be either/both shift keys\r\n        const isShift: boolean = this._app.systems.inputSystem.isKeyDown('m')\r\n\r\n        if (this._app.systems.inputSystem.isKeyDown('a')) {\r\n            //ACTION!\r\n            moveVector.x += -1;\r\n        }\r\n        if (this._app.systems.inputSystem.isKeyDown('d')) {\r\n            moveVector.x += 1;\r\n        }\r\n        if (this._app.systems.inputSystem.isKeyDown('w')) {\r\n            moveVector.y += -1;\r\n        }\r\n        if (this._app.systems.inputSystem.isKeyDown('s')) {\r\n            moveVector.y += 1;\r\n        }\r\n\r\n        if (this._app.systems.inputSystem.isKeyDownThisFrame('Enter') ||         //works\r\n            this._app.systems.inputSystem.isKeyDownThisFrame('Spacebar')) {      //does work. TODO: WHy?\r\n\r\n            //ACTION!\r\n            this._app.systems.audioSystem.play(\"./assets/audio/Click01.wav\");\r\n\r\n            //DO something here like attack\r\n        }\r\n\r\n\r\n        if (this._app.systems.inputSystem.isKeyDownThisFrame('f')) {\r\n\r\n            //FULLSCREEN\r\n            this._app.isFullscreen = !this._app.isFullscreen;\r\n            this._app.systems.audioSystem.play(\"./assets/audio/Click01.wav\");\r\n        }\r\n\r\n        if (this._app.systems.inputSystem.isKeyDownThisFrame('r')) {\r\n\r\n            //FULLSCREEN\r\n            this._app.systems.audioSystem.play(\"./assets/audio/Click01.wav\");\r\n            this._app.reload();\r\n\r\n        }\r\n\r\n        const movementSpeed = (isShift ? 10.0 : 3.0);\r\n        const nextX = this.position.x + moveVector.x * ticker.deltaTime * movementSpeed;\r\n        const nextY = this.position.y + moveVector.y * ticker.deltaTime * movementSpeed;\r\n\r\n        //TODO: Sanity check this logic to slide along walls\r\n        if (moveVector.x !== 0 && !this.isCollisionWithTilemap(nextX, this.position.y)) {\r\n            this.position.x = nextX;\r\n        }\r\n\r\n        if (moveVector.y !== 0 && !this.isCollisionWithTilemap(this.position.x, nextY)) {\r\n            this.position.y = nextY;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public override onCollision(collisions: PIXI.Container[]): void {\r\n\r\n\r\n        //TEMP: ENABLE THIS TO TEST - only do collisions on button click\r\n        // if (!this._app.systems.inputSystem.isKeyDownThisFrame('Enter')) {\r\n        //     return;\r\n        // }\r\n\r\n        collisions.forEach((collision) => {\r\n\r\n            //Note the label is NOT always the class name\r\n            //console.log(\"player is colliding with...\");\r\n            //console.log(collision.name);\r\n\r\n            //Strong typing is optional, but recommended\r\n            const myGixiAppData: ITreasurHunterData =\r\n                (this._app.configuration.data as ITreasurHunterData);\r\n\r\n            if (collision instanceof CoinTilemapObject) {\r\n                if (!collision.isCollected) {\r\n                    collision.collect();\r\n                    myGixiAppData.coinsCollected.Value++;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (collision instanceof ChestTilemapObject) {\r\n                if (!collision.isCollected) {\r\n                    collision.collect();\r\n                    return;\r\n                }\r\n            }\r\n\r\n        });\r\n    }\r\n}\r\n\r\n","import { ActorStatic, ActorStaticConfiguration } from '@src/scripts/client/gixi/ActorStatic';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\n\r\n/**\r\n * Represents a spawnpoint in the game.\r\n * \r\n */\r\nexport class BaseSpawnpointTilemapObject extends ActorStatic {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Fields ---------------------------------------\r\n\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<ActorStaticConfiguration>) {\r\n\r\n        super(app, configuration);\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (BaseSpawnpointTilemapObject).name;\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // Local\r\n        // Do any additional initialization here\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n}\r\n","import { ActorStaticConfiguration } from '@src/scripts/client/gixi/ActorStatic';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { BaseSpawnpointTilemapObject } from './base/BaseSpawnpointTilemapObject';\r\n\r\n/**\r\n * Represents a spawnpoint in the game.\r\n * \r\n */\r\nexport class PlayerSpawnpointTilemapObject extends BaseSpawnpointTilemapObject {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Fields ---------------------------------------\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<ActorStaticConfiguration>) {\r\n\r\n        super(app, configuration);\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (PlayerSpawnpointTilemapObject).name;\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // Local\r\n        // Do any additional initialization here\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n}\r\n","import { ActorStaticConfiguration } from '@src/scripts/client/gixi/ActorStatic';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { BaseSpawnpointTilemapObject } from './base/BaseSpawnpointTilemapObject';\r\n\r\n/**\r\n * Represents a spawnpoint in the game.\r\n * \r\n */\r\nexport class EnemySpawnpointTilemapObject extends BaseSpawnpointTilemapObject {\r\n\r\n    // Properties -----------------------------------\r\n\r\n    // Fields ---------------------------------------\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<ActorStaticConfiguration>) {\r\n\r\n        super(app, configuration);\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (EnemySpawnpointTilemapObject).name;\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // Local\r\n        // Do any additional initialization here\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n}\r\n","import * as PIXI from 'pixi.js';\r\nimport { ChestTilemapObject } from \"./tileMapObjects/ChestTilemapObject\";\r\nimport { CoinTilemapObject } from './tileMapObjects/CoinTilemapObject';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { ITilemapItemFactory, LayerType, TilemapItemData } from '@src/scripts/client/gixi/tilemap/Tilemap';\r\nimport { ActorStaticConfiguration } from '@src/scripts/client/gixi';\r\nimport { ITreasurHunterData } from '@src/scripts/client';\r\nimport { PlayerSpawnpointTilemapObject } from './tileMapObjects/PlayerSpawnpointTilemapObject';\r\nimport { EnemySpawnpointTilemapObject } from './tileMapObjects/EnemySpawnpointTilemapObject';\r\nimport { Tilemap } from '../../../gixi/tilemap/Tilemap';\r\n\r\nexport class TilemapItemFactoryCustom implements ITilemapItemFactory {\r\n\r\n  // Fields ---------------------------------------\r\n  private _app: GixiApplication;\r\n\r\n  // Initialization -------------------------------\r\n  constructor(app: GixiApplication,) {\r\n    this._app = app;\r\n  }\r\n\r\n  // Methods --------------------------------------\r\n  public async createTilemapItem(tilemap: Tilemap, tilemapItemData: TilemapItemData): Promise<PIXI.Container> {\r\n\r\n    //Strong typing is optional, but recommended\r\n    const myGixiAppData: ITreasurHunterData =\r\n      (this._app.configuration.data as ITreasurHunterData);\r\n\r\n\r\n    switch (tilemapItemData.layerType) {\r\n\r\n      case LayerType.TileLayer:\r\n        return new PIXI.Sprite(tilemapItemData.texture);\r\n\r\n      case LayerType.ObjectGroup:\r\n\r\n        //console.log(`createTilemapItem: (${tilemapItemData.row},${tilemapItemData.column}) ` + tilemapItemData.type);\r\n\r\n        switch (tilemapItemData.type) {\r\n\r\n\r\n          //////////////////////////////////////////\r\n          case (ChestTilemapObject).name:\r\n\r\n            const configuration: ActorStaticConfiguration = {\r\n              textureUrl: '',\r\n              texture: tilemapItemData.texture,\r\n              canCollisionCheck: false,\r\n              isTickable: true,\r\n              isResizable: false\r\n            }\r\n            return new ChestTilemapObject(this._app, configuration);\r\n\r\n\r\n          //////////////////////////////////////////\r\n          case (CoinTilemapObject).name:\r\n            myGixiAppData.coinsMax.Value++;\r\n            return new CoinTilemapObject(this._app);\r\n\r\n\r\n          //////////////////////////////////////////\r\n          case (PlayerSpawnpointTilemapObject).name:\r\n            let playerSpawnpointTilemapObject = new PlayerSpawnpointTilemapObject(this._app, { texture: tilemapItemData.texture });\r\n            playerSpawnpointTilemapObject.alpha = 0.1;\r\n\r\n            //TODO: HACK - make this show up on the \"P\" icon of the map\r\n            console.log(\"#hack Tilemap positions player poorly.\")\r\n            let p = new PIXI.Point(tilemapItemData.x / 2 - 116, tilemapItemData.y / 2 + 8); //hack\r\n            this._app.configuration.data.playerSpawnpoint = tilemap.toGlobal(p); //hack\r\n            return playerSpawnpointTilemapObject;\r\n\r\n\r\n\r\n          //////////////////////////////////////////\r\n          case (EnemySpawnpointTilemapObject).name:\r\n            let enemySpawnpointTilemapObject = new EnemySpawnpointTilemapObject(this._app, { texture: tilemapItemData.texture });\r\n            enemySpawnpointTilemapObject.alpha = 0.1;\r\n\r\n            console.log(\"#hack Tilemap positions enemy poorly.\")\r\n            this._app.configuration.data.enemySpawnpoint = new PIXI.Point(400, 400);\r\n\r\n            return enemySpawnpointTilemapObject;\r\n\r\n\r\n          //////////////////////////////////////////\r\n          default:\r\n            return new PIXI.Sprite(tilemapItemData.texture);\r\n\r\n        }\r\n    }\r\n  }\r\n}","import { EventEmitter } from 'events';\r\n\r\ninterface IEvent<TPrevious, TCurrent> {\r\n    on(listener: (previousValue: TPrevious, currentValue: TCurrent) => void): void;\r\n    off(listener: (previousValue: TPrevious, currentValue: TCurrent) => void): void;\r\n    invoke(previousValue: TPrevious, currentValue: TCurrent): void;\r\n}\r\n\r\nclass RmcEvent<TPrevious, TCurrent> implements IEvent<TPrevious, TCurrent> {\r\n    private eventEmitter = new EventEmitter();\r\n    private eventName = 'valueChanged';\r\n\r\n    on(listener: (previousValue: TPrevious, currentValue: TCurrent) => void): void {\r\n        this.eventEmitter.on(this.eventName, listener);\r\n    }\r\n\r\n    off(listener: (previousValue: TPrevious, currentValue: TCurrent) => void): void {\r\n        this.eventEmitter.off(this.eventName, listener);\r\n    }\r\n\r\n    invoke(previousValue: TPrevious, currentValue: TCurrent): void {\r\n        this.eventEmitter.emit(this.eventName, previousValue, currentValue);\r\n    }\r\n\r\n    refresh(previousValue: TPrevious, currentValue: TCurrent): void {\r\n        this.invoke(previousValue, currentValue);\r\n    }\r\n}\r\n\r\nexport class Observable<TValue> {\r\n    public readonly OnValueChanged: IEvent<TValue | undefined, TValue>;\r\n\r\n    private _currentValue: TValue;\r\n    private _previousValue: TValue | undefined;\r\n\r\n    constructor(initialValue?: TValue) {\r\n        this.OnValueChanged = new RmcEvent<TValue | undefined, TValue>();\r\n        if (initialValue !== undefined) {\r\n            this._currentValue = initialValue;\r\n            this._previousValue = initialValue;\r\n        } else {\r\n            throw new Error(\"Initial value must be provided\");\r\n        }\r\n    }\r\n\r\n    get Value(): TValue {\r\n        return this._currentValue;\r\n    }\r\n\r\n    set Value(newValue: TValue) {\r\n        this._currentValue = this.OnValueChanging(this._currentValue, newValue);\r\n        this.OnValueChanged.invoke(this._previousValue, this._currentValue);\r\n        this._previousValue = this._currentValue;\r\n    }\r\n\r\n    protected OnValueChanging(previousValue: TValue, newValue: TValue): TValue {\r\n        return newValue;\r\n    }\r\n\r\n    public refreshValueChanged(): void {\r\n        (this.OnValueChanged as RmcEvent<TValue | undefined, TValue>).refresh(this._previousValue, this._currentValue);\r\n    }\r\n}\r\n","import { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { ActorStatic } from '../../gixi/ActorStatic';\r\nimport { Graphics } from 'pixi.js';\r\nimport { Text } from 'pixi.js';\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class DebugMarker extends ActorStatic {\r\n\r\n\r\n    // Properties -----------------------------------\r\n\r\n\r\n    // Fields ---------------------------------------\r\n    private displayMessage: string;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, displayMessage: string) {\r\n\r\n        super(app);\r\n        this.displayMessage = displayMessage;\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (DebugMarker).name;\r\n\r\n    }\r\n\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // Local\r\n        const graphics = new Graphics()\r\n            .rect(0, 0, 32, 32)\r\n            .fill({\r\n                color: 0xffffff,\r\n                alpha: 0.5\r\n            });\r\n\r\n        graphics.x = - graphics.width / 2\r\n        graphics.y = - graphics.height / 2\r\n        this.addChild(graphics);\r\n\r\n        const text: Text = new Text(this.displayMessage, { align: 'center', fontSize: 12, fill: 0xffffff });\r\n        text.x = - text.width / 2\r\n        text.y = - text.height / 2\r\n        this.addChild(text);\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n\r\n    // Event Handlers -------------------------------\r\n}\r\n\r\n","import * as PIXI from 'pixi.js';\r\nimport { GixiApplication } from '@src/scripts/client/gixi/GixiApplication';\r\nimport { DropShadowFilter } from 'pixi-filters';\r\nimport { ActorStatic, ActorStaticConfiguration } from '../../gixi/ActorStatic';\r\nimport { Tilemap } from '../../gixi/tilemap/Tilemap';\r\nimport { ICollisionSystemBody } from '../../gixi/interfaces/ICollisionSystemBody';\r\nimport { Player } from './Player';\r\n\r\n/**\r\n * Configuration\r\n */\r\nexport interface EnemyConfiguration extends ActorStaticConfiguration {\r\n    moveSpeed: number;\r\n}\r\n\r\nconst EnemyConfigurationDefault: EnemyConfiguration = {\r\n\r\n    moveSpeed: 0.25,\r\n\r\n    textureUrl: '',\r\n    texture: PIXI.Texture.EMPTY,\r\n    canCollisionCheck: true,\r\n    isTickable: true,\r\n    isResizable: true\r\n}\r\n\r\n/**\r\n * Represents a coin in the game.\r\n * \r\n */\r\nexport class Enemy extends ActorStatic implements ICollisionSystemBody {\r\n\r\n\r\n    // Properties -----------------------------------\r\n    public get canCollisionBeChecked(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override get configuration(): EnemyConfiguration {\r\n        return this._configuration as EnemyConfiguration;\r\n    }\r\n\r\n    // Fields ---------------------------------------\r\n    private target!: Player;\r\n\r\n    // Initialization -------------------------------\r\n    constructor(app: GixiApplication, configuration?: Partial<EnemyConfiguration>) {\r\n\r\n        super(app, { ...EnemyConfigurationDefault, ...configuration });\r\n\r\n        // Redeclare anything from super \r\n        // that you want differently here\r\n        this.label = (Enemy).name;\r\n\r\n    }\r\n\r\n\r\n    public override async initializeAsync() {\r\n\r\n        // Super\r\n        await super.initializeAsync();\r\n\r\n        // OPTIONAL: Try these - https://pixijs.io/filters/\r\n        this._sprite.filters = [\r\n            new DropShadowFilter({ blur: 1, alpha: 0.5, quality: 3, resolution: 2 })\r\n        ];\r\n\r\n        // Local\r\n        //Do any additional initialization here\r\n        this._sprite.anchor.set(0, 0);\r\n\r\n    }\r\n\r\n    // Methods --------------------------------------\r\n    private getStageContainersOfTypePlayer(): Player[] {\r\n        return this._app.systems.collisionSystem.stageContainers.filter(child => child instanceof Player);\r\n    }\r\n\r\n\r\n    private moveTowardsTarget(): void {\r\n\r\n        const targetX = this.target.x;\r\n        const targetY = this.target.y;\r\n        const deltaX = targetX - this.x;\r\n        const deltaY = targetY - this.y;\r\n\r\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n\r\n        if (distance > this.configuration.moveSpeed) {\r\n            const directionX = deltaX / distance;\r\n            const directionY = deltaY / distance;\r\n\r\n            this.x += directionX * this.configuration.moveSpeed;\r\n            this.y += directionY * this.configuration.moveSpeed;\r\n        } else {\r\n            // If within one step, snap to target position\r\n            this.x = targetX;\r\n            this.y = targetY;\r\n        }\r\n    }\r\n\r\n    // Event Handlers -------------------------------\r\n\r\n    public override onTick(ticker: PIXI.Ticker): void {\r\n\r\n        super.onTick(ticker);\r\n\r\n        if (!this.target) {\r\n            this.target = this.getStageContainersOfTypePlayer()[0];\r\n            console.log(\"Found : \" + this.target);\r\n        }\r\n\r\n        if (!this.target) {\r\n            return;\r\n        }\r\n\r\n        this.moveTowardsTarget();\r\n\r\n    }\r\n\r\n}\r\n\r\n","//PIXI\r\nimport * as PIXI from 'pixi.js';\r\nimport Stats from 'stats.js';\r\nimport { Actions } from 'pixi-actions';\r\nimport { GixiApplication, GixiApplicationConfiguration } from './gixi/GixiApplication';\r\nimport { Tilemap } from './gixi/tilemap/Tilemap';\r\n\r\n//TREASURE HUNTER 2D\r\nimport { InstructionsText } from '@src/scripts/client/projects/treasureHunter2D/ui/InstructionsText';\r\nimport { ScoreText } from '@src/scripts/client/projects/treasureHunter2D/ui/ScoreText';\r\nimport { Player } from '@src/scripts/client/projects/treasureHunter2D/Player';\r\nimport { TilemapItemFactoryCustom } from './projects/treasureHunter2D/tileMap/TilemapItemFactoryCustom';\r\nimport { Observable } from './core/observables/Observable';\r\nimport { DebugMarker } from './projects/treasureHunter2D/DebugMarker';\r\nimport { Enemy } from './projects/treasureHunter2D/Enemy';\r\n\r\n\r\n/////////////////////////////\r\n// PIXI Configuration\r\n/////////////////////////////\r\nPIXI.AbstractRenderer.defaultOptions.roundPixels = true; // Crisp pixels\r\nPIXI.AbstractRenderer.defaultOptions.resolution = window.devicePixelRatio || 2; // Crisp pixels\r\n\r\n\r\n/////////////////////////////\r\n// Project Configuration\r\n/////////////////////////////\r\nexport interface ITreasurHunterData {\r\n  logoImageUrl: string;\r\n  tilemapDataUrl: string;\r\n  playerTextureUrl: string;\r\n  enemyTextureUrl: string;\r\n  coinsCollected: Observable<number>;\r\n  coinsMax: Observable<number>;\r\n  screenUIMarginX: number;\r\n  screenUIMarginY: number;\r\n  playerSpawnpoint: PIXI.Point;\r\n  enemySpawnpoint: PIXI.Point;\r\n}\r\n\r\nconst treasureHunterData: ITreasurHunterData = {\r\n  logoImageUrl: 'assets/images/pixijs-logo-32x32.png',\r\n  tilemapDataUrl: 'assets/tilemaps/TreasureHunter2D.tmj',\r\n  playerTextureUrl: 'assets/images/player-default-sprite.png',\r\n  enemyTextureUrl: 'assets/images/enemy-default-sprite.png',\r\n  coinsCollected: new Observable<number>(0),\r\n  coinsMax: new Observable<number>(0),\r\n  screenUIMarginX: 10,\r\n  screenUIMarginY: 10,\r\n  playerSpawnpoint: new PIXI.Point(0, 0), //Will be set by tilemap\r\n  enemySpawnpoint: new PIXI.Point(0, 0), //Will be set by tilemap\r\n};\r\n\r\nlet scoreText: ScoreText;\r\nlet instructionsText: InstructionsText;\r\nlet player: Player;\r\nlet tempScreenCenterpoint: DebugMarker\r\nlet tempWorldOrigin: DebugMarker\r\nlet tempMapOrigin: DebugMarker\r\n\r\n\r\n/////////////////////////////\r\n// Create App\r\n/////////////////////////////\r\nconst gixiAppConfiguration: GixiApplicationConfiguration = {\r\n\r\n  //Show all values here, for readability\r\n  //Or simply use GixiApplicationConfigurationDefault\r\n  widthInitial: 1920,\r\n  heightInitial: 1080,\r\n  minFPS: 1,\r\n  maxFPS: 240,\r\n  backgroundColor: 0x87867a,\r\n\r\n  //TODO: Maybe consider to change\r\n  //1. From   0-1 data storage like     GixiApp.configuration.data...\r\n  //2. To     0-n model storage like    GixiApp.modelLocator.GetItem<TreasurHunterModel>(treasurHunterModel);\r\n  data: treasureHunterData\r\n}\r\nconst gixiAppConst = new GixiApplication('pixi-application-canvas', gixiAppConfiguration);\r\n\r\n\r\n/////////////////////////////\r\n// Setup Stats\r\n/////////////////////////////\r\nconst stats = new Stats();\r\nstats.showPanel(0);\r\nstats.dom.className = 'stats-panel';\r\ndocument.body.appendChild(stats.dom);\r\n\r\n\r\n/////////////////////////////\r\n// Setup Pixi JS DevTools\r\n// https://bit.ly/pixijs-devtools\r\n/////////////////////////////\r\n(globalThis as any).__PIXI_APP__ = gixiAppConst.app;\r\n\r\n\r\n/////////////////////////////\r\n// Handle App Initialize\r\n/////////////////////////////\r\nasync function onInitializeCompleted(gixiApp: GixiApplication) {\r\n\r\n  /////////////////////////////\r\n  // Create Tilemap\r\n  /////////////////////////////\r\n  const tilemap = new Tilemap(\r\n    gixiApp,\r\n    treasureHunterData.tilemapDataUrl,\r\n    new TilemapItemFactoryCustom(gixiApp)\r\n  );\r\n\r\n  //Initialize first, so width and height are available\r\n  await tilemap.initializeAsync();\r\n  gixiApp.addToViewport(tilemap);\r\n  tilemap.x = gixiApp.getScreenCenterpoint().x - tilemap.width / 2;\r\n  tilemap.y = gixiApp.getScreenCenterpoint().y - tilemap.height / 2;\r\n\r\n  //Add tilemap to system. One of (the only?) systems that has lazy dependencies. ok?\r\n  //TODO: maybe replace with gixiApp.systems.AddSystem<ITilemapCollisionSystem>(new Blah())\r\n  gixiApp.systems.tilemapCollisionSystem.setTilemap(tilemap);\r\n\r\n  /////////////////////////////\r\n  // DebugMarkers\r\n  /////////////////////////////\r\n  tempWorldOrigin = new DebugMarker(gixiApp, \"World(0,0)\");\r\n  gixiApp.addToViewport(tempWorldOrigin); //NOTE: addToViewpoint vs addToStage?\r\n  tempWorldOrigin.position = new PIXI.Point();\r\n\r\n  tempScreenCenterpoint = new DebugMarker(gixiApp, \"Screen(C,C)\");\r\n  gixiApp.addToViewport(tempScreenCenterpoint); //NOTE: addToViewpoint vs addToStage?\r\n  tempScreenCenterpoint.position = gixiApp.getScreenCenterpoint();\r\n\r\n  tempMapOrigin = new DebugMarker(gixiApp, \"Tilemap(0,0)\");\r\n  gixiApp.addToViewport(tempMapOrigin); //NOTE: addToViewpoint vs addToStage?\r\n  tempMapOrigin.position = tilemap.position;\r\n\r\n\r\n  /////////////////////////////\r\n  // Create Enemy\r\n  /////////////////////////////\r\n  const enemy = new Enemy(gixiApp, { textureUrl: treasureHunterData.enemyTextureUrl });\r\n  gixiApp.addToViewport(enemy);\r\n  enemy.position = gixiApp.configuration.data.enemySpawnpoint;\r\n\r\n\r\n  /////////////////////////////\r\n  // Create Player\r\n  /////////////////////////////\r\n  player = new Player(gixiApp, { textureUrl: treasureHunterData.playerTextureUrl });\r\n  gixiApp.addToViewport(player);\r\n  player.position = gixiApp.configuration.data.playerSpawnpoint;\r\n\r\n\r\n  /////////////////////////////\r\n  // Setup Camera\r\n  /////////////////////////////\r\n  gixiApp.viewport.follow(player, {\r\n\r\n    //TODO: find the settings that work VERY smoothly at fullsceen\r\n    //its close, now.  But not perfect\r\n    speed: 1,\r\n    acceleration: 1,\r\n    radius: 20\r\n  });\r\n\r\n  // Optional: Input for camera\r\n  // app.viewport\r\n  //   .drag()\r\n  //   .pinch()\r\n  //   .wheel()\r\n  //   .decelerate();\r\n\r\n\r\n  /////////////////////////////\r\n  // Create Text\r\n  /////////////////////////////\r\n\r\n  const textStyle = new PIXI.TextStyle();\r\n  textStyle.fontFamily = 'Arial';\r\n  textStyle.fontSize = 40;\r\n  textStyle.fill = '#ffffff';\r\n\r\n  //See in class for : text/position\r\n  let instructions = `Arrows / WASD To Move\\nEnter / Spacebar For Attack\\nF For Fullscreen\\nR For Restart\\nM For Move Fast`;\r\n  instructionsText = new InstructionsText(gixiApp, instructions, { textStyle: textStyle });\r\n  gixiApp.addToStage(instructionsText);\r\n\r\n  //See in class for : text/position\r\n  scoreText = new ScoreText(gixiApp, \"Replace Later\", { textStyle: textStyle });\r\n  gixiApp.addToStage(scoreText);\r\n\r\n\r\n\r\n  /////////////////////////////\r\n  // Update Systems Every Frame\r\n  /////////////////////////////\r\n  gixiApp.app.ticker.add((ticker) => {\r\n\r\n    stats.begin();\r\n    Actions.tick(ticker.deltaTime);\r\n    stats.end();\r\n  });\r\n\r\n\r\n  /////////////////////////////\r\n  // Setup Gameplay\r\n  /////////////////////////////\r\n  function onRefreshScore() {\r\n\r\n    scoreText.textString = `Coins ${treasureHunterData.coinsCollected.Value}/${treasureHunterData.coinsMax.Value}`;\r\n\r\n    //Strong typing is optional, but recommended\r\n    const myGixiAppData: ITreasurHunterData =\r\n      (gixiApp.configuration.data as ITreasurHunterData);\r\n\r\n    if (myGixiAppData.coinsCollected.Value >= myGixiAppData.coinsMax.Value) {\r\n      gixiApp.reload();\r\n    }\r\n  }\r\n  onRefreshScore();\r\n\r\n  treasureHunterData.coinsCollected.OnValueChanged.on(onRefreshScore);\r\n  treasureHunterData.coinsMax.OnValueChanged.on(onRefreshScore);\r\n\r\n\r\n\r\n}\r\n\r\n\r\n/////////////////////////////\r\n// Handle App Error\r\n/////////////////////////////\r\nfunction onInitializeError(error: Error) {\r\n  console.error(`PIXI.Application.init() failed. error = ${error}`);\r\n}\r\n\r\n\r\n/////////////////////////////\r\n// Initialize App\r\n/////////////////////////////\r\ngixiAppConst.addListener(GixiApplication.EVENT_INITIALIZE_COMPLETE, onInitializeCompleted);\r\ngixiAppConst.addListener(GixiApplication.EVENT_INITIALIZE_ERROR, onInitializeError);\r\n\r\n\r\n(async () => {\r\n  await gixiAppConst.initializeAsync();\r\n\r\n\r\n})();\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"142\":\"6f46ecf1ff524851e045\",\"151\":\"061e9e13269897ecbd38\",\"162\":\"1046d09f72d0e3563e18\",\"421\":\"796907ff150e4ce2813a\",\"440\":\"d6ee605c48ad4a368abe\",\"751\":\"1c7e18eea6655a094d79\",\"852\":\"15740e5671b245293199\"}[chunkId] + \".bundle.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [433], () => (__webpack_require__(2617)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","inProgress","SystemBase","isInitialized","this","_isInitialized","_app","constructor","app","initializeAsync","requireIsInitialized","Error","GixiUtility","textureIsNullOrEmpty","texture","EMPTY","stringIsNullOrEmpty","value","hasInterface","obj","propertyChecker","Object","keys","every","prop","ICollisionSystemBodyInterfaceLookup","canCollisionBeChecked","CollisionSystem","stageContainers","_stageContainers","stageContainersRefresh","stageContainersRefreshRecursive","stage","super","stageContainersCollidingWith","me","getCollisionsInternal","container","result","children","forEach","child","push","length","filter","hasICollisionSystemBody","isCollidingWith","other","bounds1","getBounds","bounds2","x","width","y","height","ActorContainerConfigurationDefault","canCollisionCheck","isTickable","isResizable","ActorContainer","configuration","_configuration","_canCollisionCheck","isChild","parent","_isDestroyed","ticker","add","onTickInternal","bind","addListener","GixiApplication","EVENT_RESIZE","onResizeInternal","destroy","options","remove","removeListener","onAdded","onRemoved","onResize","onTick","collisions","systems","collisionSystem","onCollision","InputSystem","_keyStateDictionary","Map","window","addEventListener","onKeyDown","onKeyUp","isKeyDown","key","getKeyStateByKey","isDown","isKeyDownThisFrame","keyState","isDownThisFrame","keyboardEvent","get","undefined","newKeyState","KeyState","set","update","AudioSystem","_audioContextResumed","setupAudioContextResume","resumeAudioContext","audioContext","context","state","resume","then","console","log","catch","err","error","once","play","filename","playAsync","warn","from","url","preload","autoPlay","isLoaded","Promise","resolve","setTimeout","speed","volume","MultiplayerSystem","isDebug","consoleLog","socket","io","on","emit","msg","id","message","data","name","TilemapCollisionSystem","_tilemap","setTilemap","tilemap","isCollision","GixiApplicationConfigurationDefault","widthInitial","heightInitial","minFPS","maxFPS","backgroundColor","Systems","tilemapCollisionSystem","inputSystem","audioSystem","multiplayerSystem","all","EventEmitter","static","isFullscreen","_isFullscreen","elem","document","getElementById","canvas","requestFullscreen","fullscreenEnabled","exitFullscreen","reload","location","_systems","viewport","_canvasId","canvasId","setMaxListeners","init","resizeTo","antialias","backgroundAlpha","powerPreference","eventMode","eventFeatures","move","globalMove","click","wheel","possible","navigator","gpu","GetRendererTypeAsString","renderer","type","screenWidth","screen","screenHeight","worldWidth","worldHeight","events","center","getScreenCenterpoint","deltaMS","EVENT_INITIALIZE_COMPLETE","setupResizeHandling","addToStage","label","EVENT_INITIALIZE_ERROR","rendererType","WEBGL","WEBGPU","BOTH","addToViewport","addChild","resize","removeFromViewport","removeChild","removeFromStage","resizeAfterDelay","getScreenScaleCurrent","collisionMap","_Tilemap","Tilemap","createCollisionMap","tilemapData","layers","tilesets","Array","fill","collisionProperties","tileset","tiles","tile","properties","property","firstgid","layer","tileIndex","localPos","globalPos","toGlobal","tileWidth","tilewidth","tileHeight","tileheight","startX","Math","floor","endX","ceil","startY","endY","tilemapGlobalPos","tileY","tileX","LayerType","_tilemapData","_tilemapDataUrl","_TilemapItemFactory","_TilemapCollisionSystem","tilemapDataUrl","TilemapItemFactory","isRenderGroup","interactive","interactiveChildren","position","scale","endsWith","response","fetch","e","json","tilesetPromises","map","imageUrl","image","replace","load","TileLayer","processTileLayer","ObjectGroup","objects","processObjectLayer","row","column","getTilesetForTile","localTileIndex","columns","rectangle","tileTexture","source","frame","tilemapItemData","layerType","getTileType","sprite","createTilemapItem","toString","padStart","object","gid","typeResult","typePrimary","typeBackup","unsetValue","i","removeChildAt","find","t","GixiTextConfigurationDefault","textStyle","GixiText","textString","_text","text","textOptions","style","resolution","InstructionsText","screenUIMarginX","screenUIMarginY","fontSize","ScoreText","MultiAnimatedSprite","_animationNameToAnimatedSprite","_textureImageURL","_spriteSheetURL","newTextureImageURL","newSpriteSheetURL","initializeAndReparent","spriteSheetAtlasResponse","spriteSheetAtlas","spriteSheet","parse","size","meta","w","h","animationName","textures","entries","animations","setSize","anchor","animationSpeed","animatedSprite","ActorAnimatedConfigurationDefault","ActorAnimated","_multiAnimatedSprite","Animations","spinAndShrink","target","delayMs","durationMs","onStart","onComplete","sequence","delay","runFunc","parallel","rotateTo","smooth2","scaleTo","riseAndGrow","moveTo","TreasureHunter2DConstants","CoinTilemapObject","whatever","isCollected","destroyAfterAnimation","filters","blur","alpha","quality","collect","ActorStaticConfigurationDefault","textureUrl","ActorStatic","_sprite","ChestTilemapObject","rotation","deltaTime","PlayerConfigurationDefault","Player","event","isCollisionWithTilemap","moveVector","isShift","movementSpeed","nextX","nextY","collision","myGixiAppData","coinsCollected","Value","BaseSpawnpointTilemapObject","PlayerSpawnpointTilemapObject","EnemySpawnpointTilemapObject","TilemapItemFactoryCustom","coinsMax","playerSpawnpointTilemapObject","p","playerSpawnpoint","enemySpawnpointTilemapObject","enemySpawnpoint","RmcEvent","eventEmitter","eventName","listener","off","invoke","previousValue","currentValue","refresh","Observable","OnValueChanged","_currentValue","_previousValue","initialValue","newValue","OnValueChanging","refreshValueChanged","DebugMarker","displayMessage","graphics","rect","color","align","EnemyConfigurationDefault","moveSpeed","Enemy","getStageContainersOfTypePlayer","moveTowardsTarget","targetX","targetY","deltaX","deltaY","distance","sqrt","directionX","directionY","defaultOptions","roundPixels","devicePixelRatio","treasureHunterData","logoImageUrl","playerTextureUrl","enemyTextureUrl","scoreText","instructionsText","player","tempScreenCenterpoint","tempWorldOrigin","tempMapOrigin","gixiAppConst","stats","showPanel","dom","className","body","appendChild","globalThis","__PIXI_APP__","async","gixiApp","enemy","follow","acceleration","radius","onRefreshScore","fontFamily","begin","tick","end","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","f","chunkId","reduce","promises","u","miniCssF","g","Function","prototype","hasOwnProperty","l","done","script","needAttach","scripts","getElementsByTagName","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","onerror","onload","clearTimeout","doneFns","parentNode","head","Symbol","toStringTag","scriptUrl","importScripts","currentScript","test","installedChunks","installedChunkData","promise","reject","errorType","realSrc","request","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}