{"version":3,"file":"751.1c7e18eea6655a094d79.bundle.js","mappings":"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","sources":["webpack:///./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","webpack:///./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","webpack:///./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","webpack:///./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  init() {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(getMaxTexturesPerBatch()),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setPipelineFromGeometryProgramAndState(\n      geometry,\n      shader.gpuProgram,\n      graphicsPipe.state\n    );\n    encoder.setGeometry(geometry);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit,\n        textureBit,\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.EMPTY._source,\n        uSampler: Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.resources.uTexture = mesh.texture.source;\n      shader.resources.uSampler = mesh.texture.source.style;\n      shader.resources.textureUniforms.uniforms.uTextureMatrix = mesh.texture.textureMatrix.mapCoord;\n    } else if (!shader.gpuProgram) {\n      warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GpuMeshAdapter };\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(getMaxTexturesPerBatch()),\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      groups: {\n        // these will be dynamically allocated\n      }\n    });\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = this._shader.gpuProgram;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState\n    );\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GpuBatchAdaptor };\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView({});\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    for (const key of Object.keys(this._hash)) {\n      this._hash[key] = null;\n    }\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexport { BindGroupSystem };\n//# sourceMappingURL=BindGroupSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\n\"use strict\";\nclass GpuBufferSystem {\n  constructor() {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._managedBuffers = [];\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n      buffer.on(\"destroy\", this.onBufferDestroy, this);\n      this._managedBuffers.push(buffer);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n    buffer.off(\"destroy\", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GpuBufferSystem };\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GpuColorMaskSystem };\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await navigator.gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexport { GpuDeviceSystem };\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry) {\n    for (const i in geometry.attributes) {\n      const attribute = geometry.attributes[i];\n      this._setVertexBuffer(attribute.location, attribute.buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount || geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexport { GpuEncoderSystem };\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GpuStencilSystem };\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n","\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL };\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL.mjs';\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexport { generateArraySyncWGSL };\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL,\n    uboSyncFunctionsWGSL\n  );\n}\n\nexport { createUboSyncFunctionWGSL };\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL.mjs';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL.mjs';\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexport { GpuUboSystem };\n//# sourceMappingURL=GpuUboSystem.mjs.map\n","\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this._buffer.destroy();\n    this._buffer = null;\n    this.data = null;\n  }\n}\n\nexport { UboBatch };\n//# sourceMappingURL=UboBatch.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0)\n        usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i].destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexport { GpuUniformBatchPipe };\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology = topology || geometry.topology;\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n    }\n    const stringKey = keyGen.join(\"\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _createVertexBufferLayouts(geometry) {\n    if (this._bufferLayoutsCache[geometry._layoutKey]) {\n      return this._bufferLayoutsCache[geometry._layoutKey];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: attribute.location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexport { PipelineSystem };\n//# sourceMappingURL=PipelineSystem.mjs.map\n","\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexport { GpuRenderTarget };\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n","import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (CanvasSource.test(colorTexture.resource)) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexport { GpuRenderTargetAdaptor };\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexport { GpuRenderTargetSystem };\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GpuShaderSystem };\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n","\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\n\nexport { GpuBlendModesToPixi };\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi.mjs';\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */\n  getColorTargets(state) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    return [\n      {\n        format: \"bgra8unorm\",\n        writeMask: 0,\n        blend\n      }\n    ];\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexport { GpuStateSystem };\n//# sourceMappingURL=GpuStateSystem.mjs.map\n","\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelHeight * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexport { gpuUploadBufferImageResource };\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n","\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { blockDataMap, gpuUploadCompressedTextureResource };\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n","\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexport { gpuUploadImageResource };\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n","import { gpuUploadImageResource } from './gpuUploadImageSource.mjs';\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\nexport { gpuUploadVideoResource };\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n","\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexport { GpuMipmapGenerator };\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\n\"use strict\";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */ Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._textureViewHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    this._gpuSources[source.uid] = gpuTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    const bindGroupId = source.uid;\n    this._bindGroupHash[bindGroupId] = new BindGroup({\n      0: source,\n      1: source.style\n    });\n    return this._bindGroupHash[bindGroupId];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      // eslint-disable-next-line max-len\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: navigator.gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GpuTextureSystem };\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter.mjs';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { BindGroupSystem } from './BindGroupSystem.mjs';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem.mjs';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem.mjs';\nimport { GpuDeviceSystem } from './GpuDeviceSystem.mjs';\nimport { GpuEncoderSystem } from './GpuEncoderSystem.mjs';\nimport { GpuStencilSystem } from './GpuStencilSystem.mjs';\nimport { GpuUboSystem } from './GpuUboSystem.mjs';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe.mjs';\nimport { PipelineSystem } from './pipeline/PipelineSystem.mjs';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem.mjs';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem.mjs';\nimport { GpuStateSystem } from './state/GpuStateSystem.mjs';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGPURenderer };\n//# sourceMappingURL=WebGPURenderer.mjs.map\n"],"names":["GpuGraphicsAdaptor","init","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","gpuProgram","name","bits","colorBit","generateTextureBatchBit","localUniformBit","roundPixelsBit","this","shader","Shader","resources","execute","graphicsPipe","renderable","context","customShader","renderer","contextSystem","graphicsContext","geometry","instructions","getContextRenderData","encoder","setPipelineFromGeometryProgramAndState","state","setGeometry","globalUniformsBindGroup","globalUniforms","bindGroup","setBindGroup","localBindGroup","renderPipes","uniformBatch","getUniformBindGroup","batches","i","instructionSize","batch","groups","gpuBindGroup","textureBatch","textures","getTextureBatchBindGroup","count","getBindGroup","renderPassEncoder","drawIndexed","size","start","destroy","extension","WebGPUPipesAdaptor","GpuMeshAdapter","textureBit","_shader","uTexture","Texture","EMPTY","_source","uSampler","style","textureUniforms","uTextureMatrix","meshPipe","mesh","warn","texture","source","uniforms","textureMatrix","mapCoord","autoAssignGlobalUniforms","autoAssignLocalUniforms","draw","_geometry","tempState","State","for2d","GpuBatchAdaptor","batchPipe","program","blendMode","pipeline","getPipeline","resetBindGroup","_touch","textureGC","setPipeline","BindGroupSystem","constructor","_hash","Object","create","_renderer","contextChange","gpu","_gpu","groupIndex","_updateKey","_key","_createBindGroup","group","device","groupLayout","layout","entries","j","resource","gpuResource","_resourceType","uniformGroup","ubo","updateUniformGroup","buffer","getGPUBuffer","offset","descriptor","bufferResource","sampler","getGpuSampler","getGpuSource","createView","push","binding","getProgramData","bindGroups","createBindGroup","key","keys","WebGPUSystem","GpuBufferSystem","_gpuBuffers","_managedBuffers","uid","createGPUBuffer","updateBuffer","gpuBuffer","data","_updateID","queue","writeBuffer","_updateSize","byteLength","destroyAll","id","on","onBufferChange","onBufferDestroy","createBuffer","fastCopy","getMappedRange","unmap","splice","indexOf","_destroyBuffer","forEach","off","GpuColorMaskSystem","_colorMaskCache","setMask","colorMask","setColorMask","GpuDeviceSystem","options","_initPromise","_createDeviceAndAdaptor","then","runners","emit","adapter","navigator","requestAdapter","powerPreference","forceFallbackAdapter","requiredFeatures","filter","feature","features","has","requestDevice","defaultOptions","GpuEncoderSystem","_boundBindGroup","_boundVertexBuffer","renderStart","commandFinished","Promise","resolve","_resolveCommandFinished","commandEncoder","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","end","setViewport","viewport","x","y","width","height","topology","_boundPipeline","_setVertexBuffer","index","setVertexBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","BYTES_PER_ELEMENT","setIndexBuffer","attributes","attribute","location","indexBuffer","_setShaderBindGroups","skipSync","_syncBindGroup","isUniformGroup","instanceCount","length","getSize","finishRenderPass","postrender","submit","finish","restoreRenderPass","renderTarget","adaptor","getDescriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","priority","GpuStencilSystem","_renderTargetStencilState","onRenderTargetChange","add","stencilState","stencilMode","DISABLED","stencilReference","_activeRenderTarget","setStencilMode","setStencilReference","remove","WGSL_ALIGN_SIZE_DATA","i32","align","u32","f32","f16","createUboElementsWGSL","uniformData","uboElements","map","uboElement","Error","Math","max","ceil","generateArraySyncWGSL","offsetToAdd","remainder","createUboSyncFunctionWGSL","createUboSyncFunction","uboSyncFunctions","GpuUboSystem","UboSystem","super","createUboElements","generateUboSync","UboBatch","minUniformOffsetAlignment","_minUniformOffsetAlignment","byteIndex","clear","addEmptyGroup","newSize","addGroup","array","_buffer","GpuUniformBatchPipe","_bindGroupHash","_buffers","_bindGroups","_bufferResources","_batchBuffer","usage","UNIFORM","COPY_DST","COPY_SRC","Buffer","renderEnd","_uploadBindGroups","_resetBindGroups","duplicate","ensureUniformGroup","syncUniformGroup","_getBindGroup","getUboResource","_getBufferResource","getArrayBindGroup","getArrayBufferResource","BufferResource","BindGroup","bufferSystem","firstBuffer","update","copyBufferToBuffer","WebGPUPipes","topologyStringToId","PipelineSystem","_moduleCache","_bufferLayoutsCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","depthStencilAttachment","_stencilMode","_stencilState","GpuStencilModesToPixi","passEncoder","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","geometryLayout","shaderKey","getGraphicsStateKey","_blendModeId","_createPipeline","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","vertex","module","_getModule","entryPoint","fragment","targets","primitive","cullMode","multisample","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","attributeKeys","sort","stride","stringKey","join","createIdFromString","vertexBuffersLayout","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","divisor","instance","shaderLocation","stencilStateId","multiSampleCount","GpuRenderTarget","contexts","msaaTextures","GpuRenderTargetAdaptor","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","copyTextureToTexture","origin","startRenderPass","clearColor","getGpuRenderTarget","getCurrentTexture","colorTextures","clearValue","ALL","NONE","colorAttachments","view","resolveTarget","mipLevelCount","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","renderPassDescriptor","gpuCommands","initGpuRenderTarget","isRoot","colorTexture","CanvasSource","test","getContext","alphaMode","transparent","configure","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","e","console","error","antialias","msaaTexture","TextureSource","destroyGpuRenderTarget","unconfigure","resizeGpuRenderTarget","resize","_resolution","GpuRenderTargetSystem","RenderTargetSystem","GpuShaderSystem","_gpuProgramData","_createGPUProgramData","gpuLayout","createBindGroupLayout","pipelineLayoutDesc","bindGroupLayouts","createPipelineLayout","GpuBlendModesToPixi","alpha","srcFactor","dstFactor","operation","color","GpuStateSystem","defaultState","blend","normal","gpuUploadBufferImageResource","upload","gpuTexture","total","pixelWidth","pixelHeight","bytesPerPixel","writeTexture","rowsPerImage","bytesPerRow","depthOrArrayLayers","blockDataMap","blockBytes","blockWidth","blockHeight","defaultBlockData","gpuUploadCompressedTextureResource","mipWidth","mipHeight","blockData","levelBuffer","mipLevel","gpuUploadImageResource","min","resourceWidth","resourceHeight","premultipliedAlpha","copyExternalImageToTexture","gpuUploadVideoResource","GpuMipmapGenerator","createSampler","minFilter","pipelines","_getMipmapPipeline","mipmapShaderModule","generateMipmap","dimension","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","createTexture","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","baseMipLevel","baseArrayLayer","dstMipLevel","dstView","r","g","b","a","mipLevelSize","GpuTextureSystem","managedTextures","_gpuSources","_gpuSamplers","_textureViewHash","_uploads","image","video","compressed","initSource","autoGenerateMipmaps","biggestDimension","floor","log2","uploadMethodId","textureDescriptor","includes","onSourceUpdate","onSourceResize","onSourceDestroy","onSourceUnload","onUpdateMipmaps","_mipmapGenerator","_initSampler","_resourceId","getTextureBindGroup","_createTextureBindGroup","bindGroupId","_createTextureView","generateCanvas","canvas","get","createCanvas","getPreferredCanvasFormat","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","drawImage","imageData","getImageData","pixels","Uint8ClampedArray","returnCanvasAndContext","slice","k","Number","DefaultWebGPUSystems","SharedSystems","DefaultWebGPUPipes","DefaultWebGPUAdapters","systems","renderPipeAdaptors","handleByNamedList","WebGPURenderer","AbstractRenderer","WEBGPU"],"sourceRoot":""}